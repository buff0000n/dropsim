<html>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<head>
    <title>Warframe Drop Simulator</title>
</head>
<!-- embedded favicon because why not -->
<link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAANH5AADR+QGceVN3AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAetJREFUeNqMkz+oklEYxp8jtw8xMVEX+fyzhAjdJkN0aHBICEIiPt2dBBFB3CJwsLi7qJuTOCjOYZAUOElg1JVMhwvaouXQDUoT8Wnxky+vdT3wDO857/M7vO97jiCJI5Z3PB4r8/lcdrvdH202WxPANwAAyf9quVw+SqfT3y0WCyVJotPpZKFQ+EzylCT2kx/W6/XX+Xz+U6PReEkykUqlpgC4r2w2+5XkHa35SSgU+ivJ4/HQbDbvYlmWORwOC5PJJFWtVt+2Wq13KuBBqVR6f+gmrVwuF1er1eOt58ZmszkFSVxcXDyLRCK/ZFlmrVbrybL8T0iz2XylLRsk0ev1zqLRKLvdbpGkLpPJfDlkNplMVBTlN0lZBegAYL1em8Ph8A+/3/8cwCYYDJ7vz1Gv1yMWi2E2m0kATOq+2JLukrTpdLo3ADAej596vd4XDocDkiQBAJLJJPr9PoQQ03K5fBvATwA4AQAhxLkQQoWarFarFAgEMBqNkEgkYLfb0el00G630el0zlTzoYd0L5fLTY1G465uIQSFEATAeDxOkvevNFFVpVLpXjfKYrH4QevRafokDYdD+bpPMRgM7ABuqrEWgCM/ltjqKuDIpZaD3RTUA5/Pd6koyi2DwbA+5FwsFid+v/9SC/gzAD0ZXxYwq1doAAAAAElFTkSuQmCC" rel="icon" type="image/png" />
<style type="text/css">
    /* basic styles */

    * {
        font-family: sans-serif;
        color: #B0B0B0;
    }
    body {
        background-color: #202020;
    }
    .title {
	    font-weight: bold;
	    font-size: 100%;
	    color: #80A0D0;
	    display: inline;
    }
    .titleBar {
        background-color: #404040;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
        text-align: middle;
    }
    .titleBar .businessDiv {
        margin: 2ex 1ex 1ex 1ex;
    }
    .mainTitle {
	    font-weight: bold;
	    text-align: center;
	    font-size: 200%;
	    color: #FFFFFF;
    }
    .subTitle {
	    font-weight: bold;
	    text-align: center;
	    font-size: 150%;
	    color: #FFFFFF;
    }
    .label {
        color: #FFFFFF;
    }
    #errorBar {
	    text-align: center;
    }
    #error {
        background-color: #B00000;
	    font-weight: bold;
	    text-align: left;
	    color: #FFFFFF;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
        display: inline-block;
    }
    .errorLine {
	    font-weight: bold;
	    color: #FFFFFF;
    }
    #lotsOfWordsContainer, .footerContainer {
        background-color: #202020;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
   	    text-align: center;
    }
    .lotsOfWords, .footer {
        max-width: 100ex;
        display: inline-block;
   	    text-align: left;
    }
    .footer {
	    font-weight: bold;
	    font-size: 100%;
    }
    a {
        color: #8080FF
    }
    a:visited {
        color: #D080FF
    }
    .modelTitle {
	    font-weight: bold;
	    font-size: 150%;
	    color: #80A0D0;
	    display: inline;
    }
    #scenario {
        text-align: center;
    }
    .scenarioDiv {
        display: inline-block;
        text-align: left;
    }

    #scenario .missionTable {
        margin: auto;
    }
    #scenarioResults, .resultsTable {
        margin: auto;
	}
	.resultsTable {
        border-width: 0.25ex 0ex 0ex 0ex;
        border-style: solid;
        border-color: #80A0D0;
        padding: 1ex;
	}
    .worstCase {
        margin-left: 4ex;
        font-size: 75%;
        color: 808080;
    }
    .drop, .item, .mission, .add {
        border-width: 0ex 0ex 0ex 0.25ex;
        border-style: solid;
        border-color: #80A0D0;
        color: #FFFFFF;
        margin: 0ex 0ex 0ex 3ex;
        padding: 0ex 0ex 0ex 3ex;
	}
    .mission {
        border-width: 0.25ex 0ex 0ex 0.25ex;
    }
    .missionTable {
        margin: 1ex 1ex 1ex 3ex;
	}
    .button {
        margin: 1ex 1ex 1ex 1ex;
	}
	.utilGroup {
	    text-align: center;
	}
    #scenario .fieldTable {
        width: 50ex;
    }
    .button, .examplesDiv, .stopAfterDiv, .autoStartDiv, .start, .stop, .urlButton {
        background-color: #808080;
        border: none;
        color: #FFFFFF;
        padding: 1ex;
        text-align: center;
        text-decoration: none;
        font-size: 100%;
        border-radius: 1ex;
    }
    .start {
        background-color: #60A060;
    }
    .stop {
        background-color: #A06060;
    }
    .delete, .clear {
        background-color: #604040;
    }
    .addButton {
        background-color: #404060;
    }
    .urlButton, .examplesDiv, .autoStartDiv {
        background-color: #406080;
    }
    .stopAfterDiv {
        background-color: #404040;
    }
    .stopAfterDiv input {
        /* why is the auto stop text box so hard to center? */
        vertical-align: 15%;
    }
    .density, .cumulative {
        background-color: #404040;
        color: #D0D0D0;
    }
    .densitySelected, .cumulativeSelected {
        background-color: #80A0D0;
        color: #FFFFFF;
    }
    .inputName, .inputTime, .inputRequired, .inputCount, .inputRate, .inputStopAfter {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
        font-size: 75%;
        padding: 1ex;
        border-radius: 1ex;
    }
    .inputBailEarly, #copyUrlAutoStart {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
    }
    #samplesSelect {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
        font-size: 100%;
        padding: 1ex;
        border-radius: 1ex;
    }
    .button:disabled {
        background-color: #404040;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    .inputName:disabled, .inputTime:disabled, .inputRequired:disabled, .inputCount:disabled, .inputRate:disabled, .inputStopAfter:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    .inputStopAfter:disabled {
        background-color: #404040;
    }
    .inputBailEarly:disabled, #copyUrlAutoStart:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    #samplesSelect:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    .missionResults, .trialResult table tr td, .timeResult table tr td {
        vertical-align: text-top;
    }
    .util {
        display: inline;
        margin: 1ex 0ex 1ex 0ex;
    }
    .about {
        text-align: center;
    }
    h1, h2, h3, h4 {
        color: A0C0F0;
    }
    strong {
        color: 6080B0;
    }
    .warn {
        color: D06040;
    }
    .notes tr td:first-child {
        width: 25%;
        text-align: right;
        vertical-align: text-top;
    }

    .tooltip a {
        color: #0000FF
    }
    .tooltip a:visited {
        color: #B000FF
    }

    /* tooltips, adapted from https://www.w3schools.com/css/css_tooltip.asp */

    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        width: 50ex;
        background-color: #FFFFFF;
        color: #4040A0;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 1ex;
        left: calc(100% + 2ex);

        opacity: 0;
        transition: opacity 500ms;
        transition-delay: 1s;
    }

    .tooltip .tooltiptextbottom {
        visibility: hidden;
        width: 30ex;
        background-color: #FFFFFF;
        color: #4040A0;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 120%;
        left: calc(50% - 15ex);
        margin-left: -2ex;

        opacity: 0;
        transition: opacity 500ms;
        transition-delay: 1s;
    }

    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 2.25ex;
        right: 100%;
        margin-top: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent #FFFFFF transparent transparent;
    }

    .tooltip .tooltiptextbottom::after {
        content: "";
        position: absolute;
        bottom: 100%;  /* At the top of the tooltip */
        left: 50%;
        margin-left: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent transparent #FFFFFF transparent;
    }

    .tooltip:hover .tooltiptext, .tooltip:hover .tooltiptextbottom  {
        visibility: visible;
        opacity: 1;
    }

    /* adapted from https://www.w3schools.com/howto/howto_js_popup.asp */

    .popup {
        position: relative;
        display: inline-block;
        cursor: pointer;
    }

    .popup .popuptext {
        visibility: hidden;
        width: 50ex;
        background-color: #FFFFFF;
        color: #000080;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 120%;
        left: -40ex;
        margin-left: -2ex;
    }

    .popup .popuptext::after {
        content: "";
        position: absolute;
        bottom: 100%;  /* At the top of the tooltip */
        right: 2ex;
        margin-left: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent transparent #FFFFFF transparent;
    }

    .popup .show {
        visibility: visible;
        animation: fadeIn 1s
    }

    #urlHolder {
        color: #000000;
    }

    /*
        Huge hack to configure the histogram chart through CSS
        The 'content' property can contain anything, does not affect a <canvas> element, and can be read by javascript
        using getComputedStyle()

        bg: background color
        l: line color
        t: text color
        to: text outline color
        b: bar color
        bh: bar highlight color
        bhbg: bar highlight background color
        fs: font size
    */
    .histogram {
        content: "bg=#202020;l=#B0B0B0;t=#B0B0B0;to=#202020;b=#80A0D0;bh=#A0C0FF;bhbg=#204050;fs=15";
    }

</style>
<script type="text/javascript" language="javascript">

    //==============================================================
	// Data model
    //==============================================================

    // formatting characters for serializing/deserializing the scenario configuration
	FIELD_SEP = '_';
	GROUP_START = '{';
	GROUP_END = '}';

    // config model for a single item
	class Item {
	    constructor() {
    		this.name = "Item";
    		this.prob = 10.0;
    		this.required = 1;
        }

		toString() {
		    // serialize to a string
			return writeName(this.name) + FIELD_SEP + this.prob.toFixed(4) + FIELD_SEP + this.required;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length != 3) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			this.prob = readFloat(fields[1]);
			this.required = readInt(fields[2]);
			return this;
		}
	}

    // config model for a single drop
	class Drop {
	    constructor() {
            this.name = "A";
            this.items = Array();
            this.dropsPerMission = 1;
            this.time = 0;
            this.requiredItems = 0;
        }

		add(item) {
			this.items.push(item);
		}

		toString() {
		    // serialize to a string
		    var s = writeName(this.name) + FIELD_SEP;
			s += this.dropsPerMission + FIELD_SEP;
			s += this.requiredItems + FIELD_SEP;
			s += this.time;
			for (var i = 0; i < this.items.length; i++) {
				s += FIELD_SEP + GROUP_START + this.items[i].toString() + GROUP_END;
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 5) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
   			this.dropsPerMission = readInt(fields[1]);
			this.time = readInt(fields[3]);
			for (var i = 4; i < fields.length; i++) {
				this.add(new Item().fromString(fields[i]));
			}

            // read this after adding the items
			var req = readInt(fields[2]);
			if (req > 0) {
                this.requiredItems = Math.min(req, this.items.length);
			}

			return this;
		}
	}

    // config model for a single mission
	class Mission {
    	constructor() {
    		this.name = "Mission";
    		this.drops = Array();
    		this.requiredDrops = 0;
    		this.time = 0;
    		this.bailEarly = true;
    	}

		add(drop) {
			this.drops.push(drop);
		}

		getNumDrops() {
            // add up the total number of drops, taking into account drops that repeat more than once
			var numDrops = 0;
			for (var i = 0; i < this.drops.length; i++) {
				numDrops += this.drops[i].dropsPerMission;
			}
			return numDrops;
		}

        hasTime() {
            if (this.time > 0) {
                return true;
            }
			for (var r = 0; r < this.drops.length; r++) {
				if (this.drops[r].time > 0) {
				    return true;
				}
	        }
	        return false;
        }

		toString() {
		    // serialize to a string
		    var s = writeName(this.name) + FIELD_SEP;
			s += this.requiredDrops + FIELD_SEP;
			s += this.time + FIELD_SEP;
			s += this.bailEarly ? "y" : "n";
			for (var i = 0; i < this.drops.length; i++) {
				s += FIELD_SEP + GROUP_START + this.drops[i].toString() + GROUP_END;
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 5) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			this.time = readInt(fields[2]);
			this.bailEarly = fields[3].toLowerCase() == "y";
			for (var i = 4; i < fields.length; i++) {
				this.add(new Drop().fromString(fields[i]));
			}

            // read this after adding the drops
			var req = readInt(fields[1]);
			if (req > 0) {
                this.requiredDrops = Math.min(req, this.drops.length);
			}

			return this;
		}
	}

    // config model for the full list of missions
	class Scenario {
	    constructor() {
            this.name = "Scenario";
            this.missions = Array();
        }

		add(mission) {
			this.missions.push(mission);
		}

        hasTime() {
			for (var m = 0; m < this.missions.length; m++) {
				if (this.missions[m].hasTime()) {
				    return true;
				}
	        }
	        return false;
        }

		toString() {
		    // serialize to a string
			var s = writeName(this.name);
			for (var i = 0; i < this.missions.length; i++) {
				s += FIELD_SEP + GROUP_START + this.missions[i].toString() + GROUP_END ;
			}
            return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 2) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			for (var i = 1; i < fields.length; i++) {
				this.add(new Mission().fromString(fields[i]));
			}

			return this;
		}
	}

    function readScenario(s) {
        return new Scenario().fromString(s);
    }

    function writeScenario(scenario) {
        return scenario.toString();
    }

    //==============================================================
    // Misc data model utility functions
    //==============================================================

	function writeName(name) {
	    // filter out any of our special format characters and extra whitespace
	    var re = new RegExp("[" + FIELD_SEP + GROUP_START + GROUP_END + "\\s+]", "g");
	    var name2 = name.replace(re, " ");
	    // replace whitespace with '+'

	    return name2.replace(/ /g, "+");
	}

	function readName(name) {
	    // un-replace '+' with a space
	    name = name.replace(/\+/g, " ");
	    // no funny business
	    name = name.replace(/[<>\"]/g, "");
	    return name;
	}

	function readInt(intString) {
	    // read a number from a string and convert any errors or negative values to zero.
	    var i = Number.parseInt(intString);
	    if (Number.isNaN(i) || i < 0) {
	        return 0;
	    }
	    return i;
	}

	function readFloat(intString) {
	    // read a decimal from a string and convert any errors or negative values to zero.
	    var i = Number.parseFloat(intString);
	    if (Number.isNaN(i) || i < 0) {
	        return 0.0;
	    }
	    return i;
	}

	function split(s) {
	    // split a string according to the field separator characters
	    // when a group start character is encounted, ignore any separator characters until the corresponding 
	    // group end character is encountered.

		var list = Array();
		var groupCount = 0;
		var buffer = "";

		for (var i = 0; i < s.length; i++) {
			var c = s.charAt(i);
			switch (c) {
				case FIELD_SEP:
					if (groupCount == 0) {
					    // field separator hit and we're not inside a group: add the accumulated text to the list and clear it
						list.push(buffer);
						buffer = "";
					} else {
					    // field separator hit but we're not inside a group: add it to the accumulated text
						buffer = buffer + c;
					}
					break;
				case GROUP_START:
					if (groupCount > 0) {
					    // group started while we're already in a group: add it to the accumulated text
						buffer = buffer + c;
					} // otherwise we discard the outer group characters
					// increment the nested group count
					groupCount++;
					break;
				case GROUP_END:
					groupCount--;
					if (groupCount > 0) {
					    // group ended but we're still in a group: add it to the accumulated text
						buffer = buffer + c;
					} // otherwise we discard the outer group characters
					break;
				default:
				    // everything else: add it to the accumulated text
					buffer = buffer + c;
			}
		}
		// add the last accumulated text to the list
		if (buffer.length > 0) {
			list.push(buffer);
		}
		return list;
	}

    //==============================================================
    // Result Data Model
    //==============================================================

    // this class encapsulates the actual run data, along with some basic statistical analysis
	class TrialData {
	    constructor() {
	        // The raw data distribution.  This array represents a list of buckets, one for each possible number of
	        // runs a trial took.  The value of each bucket is the total number of trials that took that number of
	        // runs to complete.
            this.dist = Array();

            // The cumulative distribution.  Each bucket represents the number of trails that took less than or equal
            // to that number of runs to complete.
            this.cDist = Array();

            // In most of the cases with the time data, we don't need a bucket for each integer minute.  We just need
            // buckets for every five minute interval, or 20 minute intervals, etc.  This tracks the scaling
            // relationship between the distribution bucket indices and the actual result data.  When we get a result
            // that doesn't fit exactly into an existing bucket we will re-scale the distribution so it fits.
            // a value of 0 means the scale hasn't been initialized.  We'll initialize it when we receive the first
            // result.
            this.scale = 0;

            // sum of the runs from all the trials
            this.total = 0;
            // the smallest number of runs in any trial
            this.min = Number.MAX_SAFE_INTEGER;
            // the largest number of runs in any trial
            this.max = 0;
            // A descriptive string from the trial with the largest number of runs.
            this.maxString = null;
            // the total number of trials.
            this.numTrials = 0;

            // statistics.  If the average is then zero it means these have not been calculated
            this.average = 0;
            this.standardDeviation;
            this.skew;
            this.kurtosis;
		}

		addResult(result, desc) {
		    // add the result from a single trial

		    // sanity check
		    if (!Number.isInteger(result)) {
		        throw "Invalid result: " + result;
		    }

            // make sure our distribution arrays are big enough and scaled appropriately for this trial's bucket
			this.ensureScaleAndSize(result);
			// increment our distibution's bucket corresponding to this trial's number of runs
			this.dist[result/this.scale] += 1;
			// increment our cumulative distribution's bucket corresponding to this trial's number of runs, along with
			// every bucket greater than that.
			for (var i = result/this.scale; i < this.cDist.length; i++) {
				this.cDist[i] += 1;
			}
			// add to our sum of all trials' runs
			this.total += result;
			// track the mininum number of runs
			if (result < this.min) {
				this.min = result;
			}
			// max is already set by ensureSize()
			if (result >= this.max) {
			    // track the maximum number of runs
				this.max = result;
				// store a string description of the maximum run
				this.maxString = desc.toString();
			}
			// increment the total number of trials
			this.numTrials++;

			// reset stats
			this.average = 0;
		}

		percentileToResult(fraction) {
		    // given a percentile as a fraction between 0 and 1, use our cumululative distibution to determine
		    // the number of runs corresponding to that percentile.

            // determine the cutoff point in number of trials
			var lookup = Math.round(this.numTrials * fraction);
			// if the cutoff is greater or equal to the total number of trials, then it's beyond our data set
			// just return the maximum number of runs
			if (lookup >= this.numTrials) {
				return this.max;
			}
			// search for either the exact cutoff value in our cumulative distribution, or the index where the cutoff
			// value would be inserted to remain sorted.
			var i = binarySearch(this.cDist, lookup);

            // found the exact cutoff in our cumulative distribution, this usually doesn't happen
			if (i >= 0) {
				return this.scale * (i + 0.5);
			}

            // found an insertion point, convert back to the index
			i = -(i + 1);
            // insertion point is index 0, so just return that, this also usually doesn't happen
			if (i == 0) {
				return this.cDist[0] / lookup;
			}

			// i is ths insertion point, so cDist[i] > lookup, and cDist[i - 1] < lookup
			// do a linear interpotation between the two, based on how far i is from one to the other.
			// finally, multiple by the scale since it's based on the bucket index
			return this.scale * ((i - 1) + (1.0 - (lookup - this.cDist[i - 1]) / (this.cDist[i] - this.cDist[i - 1])));
		}

		resultToPercentile(result) {
		    // given a specific number of runs, determine how likely is is for a trial to take that number of
		    // runs or fewer.  Essentially, what percentile is this result?

            // beyond the end of our data: 100%
			if (result >= this.max) {
				return 1.0;
			}
			// get the cumulative number of trials that took that number of runs or fewer, divided by the total
			// number of trials
			var trials = this.cDist[result/this.scale];
			return trials / this.numTrials;
		}

		reCalc() {
		    // calculate statistics of the distribution

		    // already calculated
			if (this.average != 0) {
				return;
			}

			// average is easy, the total number of runs over all trials divided by the number of trials
			this.average = (this.total) / this.numTrials;

			// standard deviation is the square root of variance, which is the second moment
			// this describes how spread out the data is from the average
			this.standardDeviation = Math.sqrt(this.moment(2));

			// skew is the third moment divided by the cube of the standard deviation
			// this describes how far away the 50th percentile is from the average
			this.skew = this.moment(3) / Math.pow(this.standardDeviation, 3);

			// kurtosis is the fourth moment divided by the 4th power of the standard deviation, minus 3 for Excess Kurtosis
			// this basically describes how many extreme ouliers there are compared to a normal distribution
			this.kurtosis = this.moment(4) / Math.pow(this.standardDeviation, 4) - 3;
		}

		moment(m) {
		    // basically, the mth moment is the average of the mth powers of the differences between each data value and the average.

		    // keep a sum
			var sum = 0;
			// iterate over each data value
			for (var t = 0; t <= this.max; t+=this.scale) {
			    // start with the difference from the average, which can be negative
				var d = (t - this.average);
				// raise the difference to the mth power
				var p = d;
				for (var i = 1; i < m; i++) {
					p *= d;
				}
				// add to the sum, we have to multiply by the number of results in the Tth bucket
				sum += (p * this.dist[t/this.scale]);
			}
			// divide by the number of data values for the average
			return sum / this.numTrials;
		}

		ensureScaleAndSize(index) {
		    if (this.scale == 0) {
		        // scale is not initialized, let's start somewhere

		        // ugh the first result is zero.  Let's handle this the lazy way and just set the scale to 1.
		        if (index == 0) {
		            this.scale = 1;

		        } else {
		            // initialize the scale so it contains the first result in bucket 1.
                    this.scale = index;
                }

		        // assuming dist and cDist are still empty
		    }

		    // see if we have to rescale

		    if ((index % this.scale) != 0) {
		        // calculate a new scale that will hold all existing buckets and the new one by just finding the
		        // greatest common divisor of the current scale and the new bucket.

                var newScale = getGcd(index, this.scale);

                // rescale the distribution, filling new buckets with zeros
    			this.dist = this.ensureScale0(this.dist, this.scale, newScale, false);

                // rescale the cumulative distribution, filling new buckets with the cumulative value before them in the array
    			this.cDist = this.ensureScale0(this.cDist, this.scale, newScale, true);

    			// set the new scale
    			this.scale = newScale;
		    }

		    // make sure our dist and cumulative dist are bigh enough for the given bucket index

		    // fill any added buckets of the distribution with zeros
			this.dist = this.ensureSize0(this.dist, (index/this.scale) + 1, false);

		    // fill any added buckets of the cumulative distribution with the current last value
			this.cDist = this.ensureSize0(this.cDist, (index/this.scale) + 1, true);

			// update the maximum bucket
			if (index > this.max) {
				this.max = index;
			}
		}

        ensureScale0(list, scale, newScale, copyFill) {
            var multiple = scale / newScale;
            var newList = new Array();
            for (var i = 0; i < list.length; i++) {
                newList.push(list[i]);
                var fill = copyFill ? list[i] : 0;
                for (var j = 1; j < multiple; j++) {
                    newList.push(fill);
                }
            }
            return newList;
        }

		ensureSize0(list, size, copyFill) {
		    // if we're copying the last value in the array to fill it and there actually is a last value,
		    // then use that to fill the added indices, otherwise use zero
    	    var fill = (copyFill && list.length > 0) ? list[list.length - 1] : 0;

    	    // not sure how arrays in Javascript actually work.  Does this create a new internal array each time
    	    // we push an element?
			while (list.length < size) {
    			list.push(fill);
			}
			return list;
		}
	}

    function binarySearch(a, key) {
        return binarySearch0(a, 0, a.length, key);
    }

    function binarySearch0(a, fromIndex, toIndex, key) {
        // this is translated directly from Java's binary search implementation, because that's what I originally wrote
        // this program in

        var low = fromIndex;
        var high = toIndex - 1;

        while (low <= high) {
            var mid = (low + high) >>> 1;
            var midVal = a[mid];

            if (midVal < key)
                low = mid + 1;  // Neither val is NaN, thisVal is smaller
            else if (midVal > key)
                high = mid - 1; // Neither val is NaN, thisVal is larger
            else {
                if (midVal == key)     // Values are equal
                    return mid;             // Key found
                else if (midVal < key) // (-0.0, 0.0) or (!NaN, NaN)
                    low = mid + 1;
                else                        // (0.0, -0.0) or (NaN, !NaN)
                    high = mid - 1;
            }
        }
        return -(low + 1);  // key not found.
    }

	function getGcd(a, b) {
	    // easy case a == b
		if (a == b) {
			return a;
		}
		// make a > b
		if (a < b) {
			var c = a;
			a = b;
			b = c;
		}
		// oh look it's the Euclidean algorithm
		for (;;) {
			var c = a % b;
			if (c == 0) {
				return b;
			}
			if (c == 1) {
				return 1;
			}
			a = b;
			b = c;
		}
	}

    //==============================================================
    // Runner Model
    //==============================================================

    // data model for generating and tracking the results from running a single drop
	class DropRunner {
	    constructor(drop) {
            this.drop = drop;
            // the actual results from all the items in this drop
	        this.x = new Array(this.drop.items.length);
            // the results from other drops that have items with the same name.
	        this.otherx = new Array(this.drop.items.length);
	        // the number of successful items, determined by the item's required number.
            this.numSuccess = 0;
            // convert the list of individual probabilities for each item to a list of cumulative probabilities, in
            // order, from 0 to 1.
            // note that this will not go all the way to 1 if the sum of the drop's desired items do not add to 100%
			this.cProbs = toCumulativeProbs(this.drop.items);
			// need to keep track of the last item from this drop in order to cross reference with other
			// drops that may have the same item
			this.lastItem = null;

    		// if the drop's required items is 0 then all items are required
            this.requiredItems = this.drop.requiredItems > 0 ? this.drop.requiredItems : this.drop.items.length;

			this.reset();
		}

		verify() {
		    var errors = Array();
		    if (this.drop.items.length == 0) {
		        errors.push("contains no items");
		    }
		    var dropNames = Array();
		    for (var d = 0; d < this.drop.items.length; d++) {
		        var item = this.drop.items[d];
		        if (item.prob <= 0 || item.prob > 100) {
    		        errors.push("item '" + item.name + "' -> invalid drop rate: '" + item.prob + "%'");
		        }
		        if (item.required == 0) {
    		        errors.push("item '" + item.name + "' -> required number is zero");
		        }
		        if (dropNames[item.name]) {
    		        errors.push("duplicate item name: '" + item.name + "'");
		        } else {
    		        dropNames[item.name] = item.name;
    		    }
		    }
		    // need to have some leeway for rounding errors
		    if (this.cProbs[this.cProbs.length - 1] > 100.1) {
		        errors.push("drop rates add to more than 100%");
		    }
		    if (this.requiredItems > this.drop.items.length) {
		        errors.push("required items is greater than the number of items");
		    }
		    if (this.drop.dropsPerMission <= 0) {
		        errors.push("number of drops is zero");
		    }
		    return errors;
		}

		reset() {
		    // reset the result data for a new run
	        for (var i = 0; i < this.x.length; i++) {
	            this.x[i] = 0;
	            this.otherx[i] = 0;
	        }
			this.numSuccess = 0;
		}

		hasSucceeded() {
		    // the drop is successful if it has seen all of its required items over the course of the run
			return this.numSuccess >= this.requiredItems;
		}

		run() {
		    // This is where the actual RNG happens.

		    // generate a random percentage between 0 and 100.
			var d = Math.random() * 100.0;
			// search our cumulative probability list for where the RNG decimal would be inserted
			var i1 = binarySearch(this.cProbs, d);
			// convert the "not found" result to an index
			if (i1 < 0) {
				i1 = -(i1 + 1);
			}
			var ret = false;
			// if the index is not past the end of the cumulative probability list
			if (i1 < this.x.length) {
			    // one of our items successfuly dropped.  increment the corresponding count
				this.x[i1]++;
				// check that item's count against its required number
				if (this.x[i1] + this.otherx[i1] == this.drop.items[i1].required) {
				    // if the item has hit its requried number, increment the number of successful items
					this.numSuccess++;
					// if the number of successful items has hit the drop's required number successes, then
					// return success
					if (this.numSuccess == this.requiredItems) {
						ret = true;
					}
				}
				this.lastItem = this.drop.items[i1];

			} else {
				this.lastItem = null;
			}

			return ret;
		}

		otherSuccess(itemName) {
			var ret = false;
		    for (var d = 0; d < this.drop.items.length; d++) {
		        if (this.drop.items[d].name == itemName) {
		            this.otherx[d]++;
                    if (this.x[d] + this.otherx[d] == this.drop.items[d].required) {
                        // if the item has hit its requried number, increment the number of successful items
                        this.numSuccess++;
                        // if the number of successful items has hit the drop's required number successes, then
                        // return success
                        if (this.numSuccess == this.requiredItems) {
    						ret = true;
                        }
                    }
		        }
		    }
			return ret;
		}
	}

    // data model for generating and tracking the results from running a single mission
	class MissionRunner {
	    constructor(mission) {
            this.mission = mission;
            // a list of drop runners for each of the mission's drops
            this.dropRunners = new Array(this.mission.drops.length);
            for (var i = 0; i < this.mission.drops.length; i++) {
                this.dropRunners[i] = new DropRunner(this.mission.drops[i]);
            }

            // see whether there is any time data to track
            this.hasTime = this.mission.hasTime();

            // if the mission's requred drop events is zero then all drop events are required
            this.requiredDrops = this.mission.requiredDrops > 0 ? this.mission.requiredDrops : this.dropRunners.length;

            // track total number of missions and total mission time
            this.totalMissions = 0;
            this.totalMissionTime = 0;

            // TrialData objects for holding the run and time results
            this.totalResults = new TrialData();
            this.totalTimeResults = !this.hasTime ? null : new TrialData();
        }

		verify() {
		    var errors = Array();
		    if (this.dropRunners.length == 0) {
		        errors.push("contains no drops");
		    }
		    for (var r = 0; r < this.dropRunners.length; r++) {
		        var dropRunner = this.dropRunners[r];
		        var dropErrors = dropRunner.verify();
		        for (var error in dropErrors) {
		            errors.push(dropRunner.drop.name + " -> " + dropErrors[error]);
		        }
		    }
		    if (this.requiredDrops > this.dropRunners.length) {
		        errors.push("required drops is greater than the number of drops");
		    }
		    return errors;
		}

		reset() {
	        // reset everything
            for (var i = 0; i < this.dropRunners.length; i++) {
				this.dropRunners[i].reset();
			}
			this.totalMissions = 0;
			this.totalMissionTime = 0;
		}

		run(scenaroRunner) {
			var numGot = 0;
            for (var r = 0; r < this.dropRunners.length; r++) {
                var dropRunner = this.dropRunners[r];
                if (dropRunner.hasSucceeded()) {
                    numGot++;
                }
            }

			// this tracks the number of drops we actually need to run.  If mission.bailEarly is set then
			// we will reduce this if the later drops succeed before the earlier ones.
			var maxDrops = this.mission.getNumDrops();

            // loop until the number of successful drops matches our required number of successful drops
			for (; numGot < this.requiredDrops; this.totalMissions++) {
			    // append the base mission time
				this.totalMissionTime += this.mission.time;
				// drop number is tracked separate from drop index, because some drops can repeat
				// multiple times
				var dropNum = 0;

                // loop over the drops
                for (var r = 0; r < this.dropRunners.length; r++) {
                    var dropRunner = this.dropRunners[r];
                    // loop over all the repetitions of the drop
					for (var i = 0; i < dropRunner.drop.dropsPerMission; i++) {
						dropNum++;
						// break early if we're past the max number of drops we need
						if (dropNum > maxDrops) {
							break;
						}

                        // append the drop time
						this.totalMissionTime += dropRunner.drop.time;

						// run the drop once, and see if it was successful
						var success = dropRunner.run()

						if (success) {
						    // drop was just now successful, so increment the number of successful drops
							numGot++;
						}

						if (dropRunner.lastItem) {
						    // if the event had a successful item drop then we need to cross reference that item's name
						    // with the other drops.
						    var otherNumGot = this.otherSuccess(dropRunner, dropRunner.lastItem.name);
						    if (otherNumGot > 0) {
                                numGot += otherNumGot;
                                success = true;
                            }

                            // we also need to cross reference with later missions in the scenario
                            scenaroRunner.otherSuccess(this, dropRunner.lastItem.name);
						}

                        // if there was a item that made any drop successful and early bailing is enabled, then
                        // we need to recalcaulate where we can bail early
						if (success && this.mission.bailEarly) {
                            // start with the total drops in the mission
                            maxDrops = this.mission.getNumDrops();
                            // loop backwards from the last drop to the first
                            for (var r2 = this.dropRunners.length - 1; r2 >= 0; r2--) {
                                var rot = this.dropRunners[r2];
                                if (rot.hasSucceeded()) {
                                    // if this drop has succeeded then decrement the maximum number of
                                    // drops we need to run
                                    maxDrops -= rot.drop.dropsPerMission;

                                } else {
                                    // otherwise, we've hit a drop that is still waiting for success, so break
                                    // the loop and leave maxDrops where it is.
                                    break;
                                }
                            }
						}
					}
				}
			}

			// we did it!

            // add the total number of mission runs to our results
			this.totalResults.addResult(this.totalMissions, this);
            // add the total amount of time to our time results, if applicable
			if (this.totalTimeResults !== null) {
				this.totalTimeResults.addResult(this.totalMissionTime, this);
			}
		}

		otherSuccess(dropRunner, lastItemName) {
    		var numGot = 0;
            for (var r2 = 0; r2 < this.dropRunners.length; r2++) {
                var dropRunner2 = this.dropRunners[r2];
                if (dropRunner2 !== dropRunner && dropRunner2.otherSuccess(lastItemName)) {
                    // the item made another drop successful, so increment the number of successful drops
                    numGot++;
                }
            }
            return numGot;
		}

        collectItems(itemSet) {
            for (var r = 0; r < this.dropRunners.length; r++) {
                var dropRunner = this.dropRunners[r];
                for (var d = 0; d < dropRunner.drop.items.length; d++) {
                    var name = dropRunner.drop.items[d].name;
                    var count = dropRunner.x[d];
                    if (!itemSet[name]) {
                        itemSet[name] = count;
                    } else {
                        itemSet[name] += count;
                    }
                }
            }
        }

		toString() {
            // produce a desciptive string of this mission's results.

            var itemSet = new Array();
            this.collectItems(itemSet);

            var s2 = "";
            for (var name in itemSet) {
                if (s2.length > 0) {
                    s2 += ", ";
                }
                s2 += name + ": " + itemSet[name];
            }

            return this.mission.name + ": " + this.totalMissions + "<br/>" + s2;
		}
	}

    // data model for generating and tracking the results from running a list of missions
	class ScenarioRunner {
	    constructor(scenario) {
            this.scenario = scenario;
            // create a mission runner for each of our missions
            this.missionRunners = new Array(this.scenario.missions.length);
            for (var i = 0; i < this.scenario.missions.length; i++) {
                this.missionRunners[i] = new MissionRunner(this.scenario.missions[i]);
            }
            // see whether there is any time data to track
            this.hasTime = this.scenario.hasTime();

            // if there is only one mission then just use its results as our own
            if (this.missionRunners.length == 1) {
                this.totalResults = this.missionRunners[0].totalResults;
                this.totalTimeResults = this.missionRunners[0].totalTimeResults;

            } else {
                // otherwise, we need our own results to aggregate the results from all the missions.
                this.totalResults = new TrialData();
                this.totalTimeResults = !this.hasTime ? null : new TrialData();
            }

            // track total number of missions and total mission time from all missions
            this.totalMissions = 0;
            this.totalMissionTime = 0;
        }

		verify() {
		    var errors = Array();
		    if (this.missionRunners.length == 0) {
		        errors.push("contains no missions");
		    }
		    for (var r = 0; r < this.missionRunners.length; r++) {
		        var missionRunner = this.missionRunners[r];
		        var missionErrors = missionRunner.verify();
		        for (var error in missionErrors) {
		            errors.push(missionRunner.mission.name + " -> " + missionErrors[error]);
		        }
		    }
		    return errors;
		}

		run() {
		    // this represents a full trial with a list of missions:  Starting from zero, running each mission
		    // in turn until it is successful, and moving on to the next mission until there're all done.

		    // reset
            for (var i = 0; i < this.missionRunners.length; i++) {
                this.missionRunners[i].reset();
            }
			this.totalMissions = 0;
			this.totalMissionTime = 0;


            for (var i = 0; i < this.missionRunners.length; i++) {
                var missionRunner = this.missionRunners[i];
                // run each mission to completion
				missionRunner.run(this);
				// add up the total number of runs and total time from each mission
				this.totalMissions += missionRunner.totalMissions;
				this.totalMissionTime += missionRunner.totalMissionTime;
			}

            // if we have our own separate results, then add our total scenario result to them
			if (this.missionRunners.length != 1) {
				this.totalResults.addResult(this.totalMissions, this);
				if (this.totalTimeResults != null) {
					this.totalTimeResults.addResult(this.totalMissionTime, this);
				}
			}
		}

		otherSuccess(lastMissionRunner, lastItemName) {
            for (var i = 0; i < this.missionRunners.length; i++) {
                var missionRunner = this.missionRunners[i];
                if (lastMissionRunner != missionRunner) {
                    missionRunner.otherSuccess(null, lastItemName);
                }
            }
		}

		toString() {
            // produce a desciptive string of this missions list's results.

		    var s = "";

            var itemSet = new Array();
            for (var m = 0; m < this.missionRunners.length; m++) {
                var missionRunner = this.missionRunners[m];
                if (m > 0) {
                    s += ", ";
                }
                s += missionRunner.mission.name + ": " + missionRunner.totalMissions;

                missionRunner.collectItems(itemSet);
            }

            var s2 = "";
            for (var name in itemSet) {
                if (s2.length > 0) {
                    s2 += ", ";
                }
                s2 += name + ": " + itemSet[name];
            }

            return s + "<br/>" + s2;
		}
	}

	function toCumulativeProbs(items) {
	    // add up the probabilities in a list of items to produce a list of cumulative probabilities
		var cProbs = new Array(items.length);
		cProbs[0] = items[0].prob;
		for (var i = 1; i < items.length; i++) {
			cProbs[i] = cProbs[i - 1] + items[i].prob;
		}
		return cProbs;
	}

    //==============================================================
    // Utility DOM functions
    // probably doing some of these the hard way but nothing else
    // was reliable enough
    // Most UI elements are identified by class instead of ID
    // because they're added dynamically and there can be more than
    // one of them in the DOM
    //==============================================================

    function getParent(node, parentClass) {
        // walk up the DOM until we find a parent with the given class name
        while (parentClass != (node.className)) {
            node = node.parentNode;
        }
        return node;
    }

    function getFirstChild(node, childClass) {
        // perform a depth first search from the first child to the last,
        // until we find an element with the given class name
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = node.children[i];
            if (child.className == childClass) {
                return child;
            }
            // recursive call
            var child2 = getFirstChild(child, childClass);
            if (child2 !== null) {
                return child2;
            }
        }
        return null;
    }

    function getLastChild(node, childClass) {
        // perform a depth first search going from the last child to the first,
        // until we find an element with the given class name
        var children = node.children;
        // go over the children in reverse order
        for (var i = children.length - 1; i >= 0; i--) {
            var child = node.children[i];
            if (child.className == childClass) {
                return child;
            }
            // recursive call
            var child2 = getLastChild(child, childClass);
            if (child2 !== null) {
                return child2;
            }
        }
        return null;
    }

    function getAllChildren(node, childClass) {
        // find all the children with the given class name
        return getAllChildren0(node, childClass, Array());
    }

    function getAllChildren0(node, childClass, list) {
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = node.children[i];
            if (child.className == childClass) {
                list.push(child);
            }
            getAllChildren0(child, childClass, list);
        }
        return list;
    }

    function deleteNode(node) {
        // delete an element from its parent
        node.parentNode.removeChild(node);
    }

    //==============================================================
    // UI Builders
    //==============================================================

    function getScenario() {
        return document.getElementById('scenario');
    }

    function clearScenario() {
        // clear the mission config and results

        // Stop any run in progress.
        stopRun();

        var missionTable = getFirstChild(getScenario(), "missionTable");
        var children = getAllChildren(missionTable, "missionRow");
        // delete all missions except for the placeholder "add" one
        for (var i = 0; i < children.length; i++) {
            deleteNode(children[i]);
        }

        // clear scenario name field
	    getFirstChild(document.getElementById("scenario"), "inputName").value = "";

        // clear the results
        clearResults()
    }

    function addMission(scenarioNode, autoPop) {
        // static HTML for each mission config
        html = `
        <tr class="missionRow">
            <td class="mission">
                <div class="modelTitle">Mission</div>
                <span class="tooltip">
                    <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'missionRow'))"/>
                    <span class="tooltiptext">Remove this mission from the list.</span>
                </span>
                <table class="fieldTable">
                    <tr>
                        <td class="tooltip">
                            Name:
                            <span class="tooltiptextbottom">The name of this mission</span>
                        </td>
                        <td>
                            <input class="inputName" type="text" value="Mission"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Mission Time:
                            <span class="tooltiptextbottom">The minimum amount of time in minutes that this mission takes, or '0' if the mission time is unknown or it's if completely determined by the drop events</span>
                        </td>
                        <td>
                            <input class="inputTime" type="number" value="0"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Drops Events Required:
                            <span class="tooltiptextbottom">The number of drop events that must successfully get all of their required items during the course of the run before this mission's is successful, or '0' if all of them are required.</span>
                        </td>
                        <td>
                            <input class="inputRequired" type="number" value="0"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Bail Early:
                            <span class="tooltiptextbottom">If enabled then a mission can be ended early if all the drop events after a certain point have already been successful earlier in the run.</span>
                        </td>
                        <td>
                            <input class="inputBailEarly" type="checkbox" checked/>
                        </td>
                    </tr>
                </table>
                <div class="add">
                    <span class="tooltip">
                        <input class="button addButton" type="submit" value="Add Drop Event" onclick="addDrop(getParent(this, 'missionRow'), true)"/>
                        <span class="tooltiptext">Add a drop event to the above mission.  Drop events are run in the order in which they are listed.</span>
                    </span>
                </div>
            </td>
            <td class="missionResults">
                <div class="trialResult"></div>
                <div class="timeResult"></div>
            </td>
        </tr>
        `;

        // find the "add" row under the scenario
        addNode = getLastChild(scenarioNode, "add");

        // insert the mission HTML before the "add" row
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "missionRow" element we just added
        newNode = addNode.previousElementSibling

        // if someone clicked the "add mission" button then go ahead and add a drop.
        if (autoPop) {
            addDrop(newNode, true);
        }

        // return the mission row element we just added
        return newNode;
    }

    function addDrop(missionNode, autoPop) {
        // static HTML for each drop config
        html = `
                <div class="drop">
                    <div class="modelTitle">Drop Event</div>
                    <span class="tooltip">
                        <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'drop'))"/>
                        <span class="tooltiptext">Remove this drop event.</span>
                    </span>
                    <table class="fieldTable">
                        <tr>
                            <td class="tooltip">
                                Name:
                                <span class="tooltiptextbottom">The name of this drop event.</span>
                            </td>
                            <td>
                                <input class="inputName" type="text" value="Drop"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Events Per Mission:
                                <span class="tooltiptextbottom">The number of times this drop event repeats in one mission, or '1' if it does not repeat.</span>
                            </td>
                            <td>
                                <input class="inputCount" type="number" value="1"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Event Time:
                                <span class="tooltiptextbottom">The amount of time it takes to get one drop event, in minutes, or '0' if the time is unknown or completely determined by the mission time.</span>
                            </td>
                            <td>
                                <input class="inputTime" type="number" value="0"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Items Required:
                                <span class="tooltiptextbottom">The number of items that must get their required number of drops during the course of a run, or '0' if all of them are required.</span>
                            </td>
                            <td>
                                <input class="inputRequired" type="number" value="0"/>
                            </td>
                        </tr>
                    </table>

                    <div class="add">
                        <span class="tooltip">
                            <input class="button addButton" type="submit" value="Add Item" onclick="addItem(getParent(this, 'drop'))"/>
                            <span class="tooltiptext">Add an item to the above drop.</span>
                        </span>
                    </div>

                </div>
        `;
        // find the "add" div under the mission
        addNode = getLastChild(missionNode, "add");

        // insert the drop HTML before the "add" div
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "drop" element we just added
        newNode = addNode.previousElementSibling

        // if someone clicked the "add drop" button then go ahead and add a item.
        if (autoPop) {
            addItem(newNode);
        }

        // todo: increment the 'Drop Events Required' field under the Mission if it was equal to the number of drop events before

        // return the drop element we just added
        return newNode;
    }

    function addItem(dropNode) {
        // static HTML for each item config
        html = `
                    <div class="item">
                        <div class="modelTitle">Item</div>
                        <span class="tooltip">
                            <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'item'))"/>
                            <span class="tooltiptext">Remove this item.</span>
                        </span>
                        <table class="fieldTable">
                            <tr>
                                <td class="tooltip">
                                    Name:
                                    <span class="tooltiptextbottom">The name of the item.</span>
                                </td>
                                <td>
                                    <input class="inputName" type="text" value="Item"/>
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Drop Rate:
                                    <span class="tooltiptextbottom">The drop rate of the item.  This is a percentage greater than 0% and less than 100%.</span>
                                </td>
                                <td>
                                    <input class="inputRate" type="number" value="10" step="0.0001"/>%
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Number Required:
                                    <span class="tooltiptextbottom">The number of times this item must drop during the course of a run to consider this item successful.</span>
                                </td>
                                <td>
                                    <input class="inputRequired" type="number" value="1"/>
                                </td>
                            </tr>
                        </table>
                    </div>
        `;
        // find the "add" div under the drop
        addNode = getLastChild(dropNode, "add");

        // insert the item HTML before the "add" div
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "item" element we just added
        newNode = addNode.previousElementSibling

        // todo: increment the 'Items Required' field under the Drop Event if it was equal to the number of items before

        // return the item element we just added
        return newNode;
    }

    function showErrors(errors) {
        // find the error bar
        var errorBarElement = document.getElementById("errorBar");
        // build and error div with a line for each error in the list
        var html = `<div id="error">`;
        for (var error in errors) {
            html += `<div class="errorLine">${errors[error]}</div>`;
        }
        html += `</div>`;
        // show
        errorBarElement.innerHTML = html;
    }

    function clearErrors() {
        // find the error bar and clear it out
        var errorBarElement = document.getElementById("errorBar");
        errorBarElement.innerHTML = "";
    }

    //==============================================================
    // Model-View control
    //==============================================================

    function initModel() {
        // javascript is working
        clearErrors();
        // on page load, see if there's a "m=..." query string
        modelString = getQueryParam("m");
        // if there is, then initialize our config
        setModelString(modelString);

        // see if the stop number was also specified
        var stopAfterString = getQueryParam("s");
        if (stopAfterString) {
            // parse and sanitize the stop number
            var stopAfter = readInt(stopAfterString);
            // update the UI
            if (stopAfter > 0) {
                document.getElementById("stopAfter").value = stopAfter;
            }
        }

        // initialize the example selector
        var select = document.getElementById("samplesSelect");
        select.value = select.options.item(0).value;

        // see if the start param was specified in the URL
        var startString = getQueryParam("start");
        if (startString) {
            // update the UI to match
            document.getElementById("copyUrlAutoStart").checked = true;
            // start the simulation automatically
            startRun();
        }
    }

    function setModelString(modelString) {
        if (modelString !== null && modelString.length > 0) {
            try {
                // parse a model from the string
                var scenarioModel = new Scenario().fromString(modelString);
                // build the UI
                setModel(scenarioModel);
                // clear any error
                clearErrors();

            } catch (error) {
                // show an error
                showErrors([error]);
            }
        }
    }

    function copyModelUrl() {
        // build a model from the UI
        var scenarioModel = getModel()

        // serialize the model to a String
        var string = scenarioModel.toString();

        // get the currently specified stop number
        var stopAfter = document.getElementById("stopAfter").value;
        // get whether autostart was enabled
        var autoStart = document.getElementById("copyUrlAutoStart").checked;
        // build a full URL using the current URL
        var url = buildQueryUrl(string, stopAfter, autoStart);

        // find the pop-up URL text field and set its contents
        var textField = document.getElementById("urlHolder");
        textField.value = url;
        // show the popup
        var popup = document.getElementById("popupBox");
        popup.classList.toggle("show");
        // focus and select the contents of the text field
        textField.focus();
        textField.select();
    }

    function hideUrlPopup() {
        // hide the popup when the text field loses focus
        var popup = document.getElementById("popupBox");
        popup.classList.toggle("show");
        // todo: the onBlur() event fails to get called sometimes in Chrome
    }

    function buildQueryUrl(paramValue, stopAfter, autoStart) {
        // get the current URL and strip out any query string
        var url = window.location.href;
        url = url.replace(/\?.*/, "");
        // append our parameters
        url += "?m=" + paramValue;
        url += "&s=" + stopAfter;
        if (autoStart) {
            url += "&start=start";
        }
        return url;
    }

    function setModel(scenarioModel) {
        // build the UI corresponding to the given model

        // clear out any existig UI
        clearScenario();
        // get the root HTML element of the scenario
        var scenario = getScenario();
        // set the scenario name
        getFirstChild(scenario, "inputName").value = scenarioModel.name;

        // loop over the missions
        for (var m = 0; m < scenarioModel.missions.length; m++) {
            var missionModel = scenarioModel.missions[m];
            // add a mission UI to the list
            var mission = addMission(scenario, false);
            // copy mission config
            getFirstChild(mission, "inputName").value = missionModel.name;
            getFirstChild(mission, "inputTime").value = missionModel.time;
            getFirstChild(mission, "inputRequired").value = missionModel.requiredDrops;
            getFirstChild(mission, "inputBailEarly").checked = missionModel.bailEarly;

            // loop over the drops in this mission
            for (var r = 0; r < missionModel.drops.length; r++) {
                var dropModel = missionModel.drops[r];
                // add a drop UI to the mission
                var drop = addDrop(mission, false);
                // copy drop config
                getFirstChild(drop, "inputName").value = dropModel.name;
                getFirstChild(drop, "inputCount").value = dropModel.dropsPerMission;
                getFirstChild(drop, "inputTime").value = dropModel.time;
                getFirstChild(drop, "inputRequired").value = dropModel.requiredItems;

                // loop over the items in this drop
                for (var d = 0; d < dropModel.items.length; d++) {
                    var itemModel = dropModel.items[d];
                    // add a item UI to the drop
                    var item = addItem(drop, false);
                    // copy item config
                    getFirstChild(item, "inputName").value = itemModel.name;
                    getFirstChild(item, "inputRate").value = itemModel.prob;
                    getFirstChild(item, "inputRequired").value = itemModel.required;
                }
            }
        }
    }

    function getModel() {
        // build a model from the current state of the UI

        // get the scenario root element
        var scenario = getScenario();
        // create a new scenario model
        var scenarioModel = new Scenario()
        // copy the name
        scenarioModel.name = getFirstChild(scenario, "inputName").value;

        // add an extra property that stores the result element for the scenario
        scenarioModel.resultElement = document.getElementById("scenarioResults");

        // loop over all the mission elements under the scenario
        var missions = getAllChildren(scenario, "mission");
        for (var m = 0; m < missions.length; m++) {
            var mission = missions[m];
            // create a new mission model and add it to the scenario
            var missionModel = new Mission();
            scenarioModel.add(missionModel);
            // copy properties, sanitizing numeric inputs
            missionModel.name = getFirstChild(mission, "inputName").value;
            missionModel.time = readInt(getFirstChild(mission, "inputTime").value);
            missionModel.bailEarly = getFirstChild(mission, "inputBailEarly").checked;

            // add an extra property that stores the result element for the mission
            missionModel.resultElement = getFirstChild(getParent(mission, "missionRow"), "missionResults");

            // loop over all the drop elements under the mission
            var drops = getAllChildren(mission, "drop");
            for (var r = 0; r < drops.length; r++) {
                var drop = drops[r];
                // create a new drop model and add it to the mission
                var dropModel = new Drop();
                missionModel.add(dropModel);
                // copy properties, sanitizing numeric inputs
                dropModel.name = getFirstChild(drop, "inputName").value;
                dropModel.dropsPerMission = readInt(getFirstChild(drop, "inputCount").value);
                dropModel.time = readInt(getFirstChild(drop, "inputTime").value);

                // loop over all the item elements under the drop
                var items = getAllChildren(drop, "item");
                for (var d = 0; d < items.length; d++) {
                    var item = items[d];
                    // create a new item model and add it to the drop
                    var itemModel = new Item();
                    dropModel.add(itemModel);
                    // copy properties, sanitizing numeric inputs
                    itemModel.name = getFirstChild(item, "inputName").value;
                    itemModel.prob = readFloat(getFirstChild(item, "inputRate").value);
                    itemModel.required = readInt(getFirstChild(item, "inputRequired").value);
                }

                // since add() can change this, set it last
                dropModel.requiredItems = readInt(getFirstChild(drop, "inputRequired").value);
            }

            // since add() can change this, set it last
            missionModel.requiredDrops = readInt(getFirstChild(mission, "inputRequired").value);
        }

        return scenarioModel;
    }

    function getQueryParam(name) {
        // from https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
        // weird that there's no built in function for this
        var url = window.location.href;
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        var results = regex.exec(url);
        if (!results) {
            return null;
        }
        if (!results[2]) {
            return '';
        }
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    //==============================================================
    // Result Viewer
    //==============================================================

    // percentiles to calculate and show
    var percentiles = [0.5, 0.9, 0.99];
    // smaller list for the histogram
    var percentilesForHistogram = [0.9, 0.99];

    function updateResult(resultElement, titles, trialData, time) {
        // update a result element, either the run totals or time totals

        // if there's no data then clear the element
        if (trialData === null) {
            resultElement.innerHTML = "";
            return;
        }

        // (re)calculate the trial data statistics
        trialData.reCalc();

        // this is basically just used to scale minutes to hours, if necessary
        var dataScale = 1.0;

        if (time) {
            // the cutoff between showing the results in minutes or hours is whether the average is more than 2 hours
            if (trialData.average > 120) {
                // scale to hours by dividing everything by 60
                titles[1] += " in Hours";
                dataScale /= 60;

            } else {
                // leave it in minutes
                titles[1] += " in Minutes";
            }
        }

        // make sure the result container is initialized
        addResultContainer(resultElement, titles);

        // update the statistics
        updateResultStatistics(resultElement, titles, trialData, dataScale);

        // (re)draw the histogram
        updateHistogram(resultElement, titles, trialData, dataScale);
    }

    function addResultContainer(resultElement, titles) {
        if (resultElement.children.length == 0) {
            // Building the base container HTML
            var html = `
                <table class="resultsTable"><tr>
                    <td>
                        <div class="about">
                            <div class="title">${concatenateTitle(titles)}</div>
                            <div class="utilGroup">
                                <div class="util">
                                    <span class="tooltip">
                                        <input class="button densitySelected" type="submit" value="Probability Density" onClick="switchToDensity(this)"/>
                                        <span class="tooltiptextbottom">This shows the <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability distribution</a>.</span>
                                    </span>
                                </div>
                                <div class="util">
                                    <span class="tooltip">
                                        <input class="button cumulative" type="submit" value="Cumulative Probability" onClick="switchToCumulative(this)"/>
                                        <span class="tooltiptextbottom">This shows the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative probability distribution</a>.</span>
                                    </span>
                                </div>
                            </div>
                        </div>
                        <div class="histogramContainer">
                        </div>
                    </td>
                    <!-- go ahead and set the width here to be similar to the canvas -->
                    <td width="550">
                        <span class="title">Statistics for ${concatenateTitle(titles)}</span><br/>
                        <div class="statistics">
                        </div>
                    </td>
                </tr></table>
            `;

            // add the HTML
            resultElement.innerHTML = html;
        }
    }

    function switchToDensity(buttonElement) {
        // find the button group containing the button
        var utilGroup = getParent(buttonElement, "utilGroup");
        // find the other button, assume it's selected
        var otherButtonElement = getFirstChild(utilGroup, "button cumulativeSelected");
        // nothing to do
        if (!otherButtonElement) {
            return;
        }

        // "select" the button that was clicked
        buttonElement.className = "button densitySelected";
        // "deselect" the other button
        otherButtonElement.className = "button cumulative";

        // ugh, don't see any other way to get at all the data we need to redraw the histogram outside of the usual
        // run loop, so just update everything
        updateAllResults(scenarioRunner);
    }

    function switchToCumulative(buttonElement) {
        // find the button group containing the button
        var utilGroup = getParent(buttonElement, "utilGroup");
        // find the other button, assume it's selected
        var otherButtonElement = getFirstChild(utilGroup, "button densitySelected");
        // nothing to do
        if (!otherButtonElement) {
            return;
        }

        // "select" the button that was clicked
        buttonElement.className = "button cumulativeSelected";
        // "deselect" the other button
        otherButtonElement.className = "button density";

        // ugh, don't see any other way to get at all the data we need to redraw the histogram outside of the usual
        // run loop, so just update everything
        updateAllResults(scenarioRunner);
    }

    function updateResultStatistics(resultElement, titles, trialData, dataScale) {
        // find and update the statistics element
        var statisticsElement = getFirstChild(resultElement, "statistics");
        var html = `
                        <table class="statsTable">
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Trials:
                                    <span class="tooltipTextBottom">The total number of trials.  Each trial starts from zero and runs each mission in the list until success.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.numTrials)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Average:
                                    <span class="tooltipTextBottom">This is the <a href="https://en.wikipedia.org/wiki/Expected_value">expected average</a> of the distribution, the average number of trials until success.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.average * dataScale).toFixed(2)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Standard Deviation:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a> basically describes how spread out the data is from the average.</span>
                                </div>
                            </td>
                            </td>
                            <td class="statValue">
                                ${(trialData.standardDeviation * dataScale).toFixed(2)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Skew:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Skewness">Skew</a> describes how slanted the data is towards one side or the other.</span>
                                </div>
                            </td>
                            </td>
                            <td class="statValue">
                                ${(trialData.skew).toFixed(4)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Excess Kurtosis:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Kurtosis">Excess kurtosis</a> basically describes how many extreme ouliers there are compared to a normal distribution.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.kurtosis).toFixed(4)}
                            </td>
                        </tr>
            `;
        // loop over all the percentiles
        for (var i = 0; i < percentiles.length; i++) {
            var percentile = percentiles[i];
            var percentileResult = trialData.percentileToResult(percentile) * dataScale;
            html += `
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    ${(percentile * 100).toFixed(0)}th Percentile:
                                    <span class="tooltipTextBottom">The expected number of runs required in order to have a ${(percentile * 100).toFixed(0)}% chance of success. ${percentile == 0.5 ? 'This is also known as the <a href="https://en.wikipedia.org/wiki/Median">median</a>' : ""}</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${percentileResult.toFixed(2)}
                            </td>
                        </tr>
            `;
        }
        // finish the HTML
        html += `
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Worst case:
                                    <span class="tooltipTextBottom">This is the maximum result from the current simulation run.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.max * dataScale).toFixed(dataScale < 1 ? 2 : 0)}
                            </td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <div class="worstCase">
                                    ${trialData.maxString}
                                </div>
                            </td>
                        </tr>
                    </table>
            `;
        statisticsElement.innerHTML = html;
    }

    function updateHistogram(resultElement, titles, trialData, dataScale) {
        // find the canvas element
        var canvas = getFirstChild(resultElement, "histogram");
        if (!canvas) {
            // either the canvas isn't there yet or it got replaced with an image when someone clicked on it
            var canvasContainer = getFirstChild(resultElement, "histogramContainer");
            canvasContainer.innerHTML = `<canvas class="histogram" height=200 width=500 onclick="convertToPng(this);"/>`;
            var canvas = getFirstChild(canvasContainer, "histogram");
        }

        var buttonGroup = getFirstChild(resultElement, "utilGroup");
        var cumulative = getFirstChild(buttonGroup, "button cumulativeSelected") !== null;

        // add to the title according to which histogram it is
        titles.push(cumulative ? "Cumulative Probability" : "Probability Density");
        // draw the histogram
        histogram(canvas, titles, trialData, dataScale, cumulative);
    }

	function histogram(canvas, titles, trialData, dataScale, cumulative) {
	    var canvasStyle = getComputedStyle(canvas);
	    var styleString = canvasStyle.getPropertyValue("content");
	    var style = parseCanvasStyle(styleString);

        // save this in a property so convertToPng() can use it for the file name
	    canvas.saveName = concatenateTitle(titles);

	    // pull out the distribution
		var h = cumulative ? trialData.cDist : trialData.dist;
		// find the 99.9% percentile.  We will cut the data off there, otherwise the data may get very, very wide
		// with the extreme 0.1% outliers.
		var max = Math.round(trialData.percentileToResult(0.999));

        // find the maximum value of the distribution
        if (cumulative) {
            // with the cumulative distribution the maximum value is the total number of trials
            var maxBucket = trialData.numTrials;

        } else {
            // with probabilty density we have to search for the max value
            var maxBucket = 0;
            for (var n = 0; n < max + 1; n++) {
                if (h[n] > maxBucket) {
                    maxBucket = h[n];
                }
            }
        }

        // get the average so we can mark it
		var average = trialData.average;

        // get the graphics context and clear it
        var context = canvas.getContext("2d");
        context.fillStyle = style['bg'];
        context.fillRect(0, 0, canvas.width, canvas.height);

        // just pick a font size
        var fontSize = Number.parseInt(style['fs']);

        // flat number of pixels to leave as space around the graph
        var margin = 5;

        // calculate the actual graph size, leaving room on the left and bottom for the axes

        // the Y axis label is only useful with the cumulative distribution
        if (cumulative) {
            // leave room for a percentage
            var graphWidth = canvas.width - (fontSize * 3);

        } else {
            var graphWidth = canvas.width - (fontSize * 1);
        }
        var graphHeight = canvas.height - (fontSize * 1.1) - margin;

        // convenience starting X coordinate for the graph
        var graphXStart = canvas.width - graphWidth;

        // all bars will have the same width
        var width = Math.ceil((graphWidth) / ((max/trialData.scale) + 1));
        // all bars will start at the bottom of the graph
        var y1 = graphHeight;

        // set the data color
        context.fillStyle = style['b'];
        // draw the bars
        for (var t = 0; t < max/trialData.scale; t++) {
            // calculate the x position of the left side of the bar
            var x1 = Math.floor(graphXStart + (t * (graphWidth - margin)) / ((max/trialData.scale) + 1));
            // calculate the height of the bar
            var height = -(h[t] * (graphHeight - margin) / maxBucket);

            // draw the bar
            context.fillRect(x1, y1, width, height);
        }

        // have to draw the average bar highlight afterwards, separately, or it might be lost in distributions
        // with more buckets than horizontal pixels.
        {
            var t = Math.floor(average / trialData.scale);
            // calculate the x position of the left side of the bar
            var x1 = Math.floor(graphXStart + (t * (graphWidth - margin)) / ((max/trialData.scale) + 1));
            // calculate the height of the bar
            var height = -(h[t] * (graphHeight - margin) / maxBucket);

            // if this bucket contains the average, color the background
            // some distributions are sparse and don't actually have a visible value in the bucket containing the
            // average, so this lets us see those
            context.fillStyle = style['bhbg'];
            // draw the background bar for the average
            context.fillRect(x1, margin, width, graphHeight + height - margin);

            // set the data color for the average a bit brighter
            context.fillStyle = style['bh'];
            // draw the bar
            context.fillRect(x1, y1, width, height);
        }

        // draw the axis borders
        context.strokeStyle = style['l'];
        context.lineWidth = fontSize/10;
        context.beginPath();
        context.moveTo(graphXStart, margin);
        context.lineTo(graphXStart, graphHeight);
        context.lineTo(canvas.width - margin, graphHeight);
        context.stroke();

        // set up the text
        context.font = fontSize + "px Arial";
        context.textAlign = "left";

        // calculate an increment for the x axis that gives us up to 10 labels
        var xAxisIncrement = Math.ceil(max / 100) * 10;
        // loop over the increments
        for (var t = 0; t < max; t+= xAxisIncrement) {
            // calculate the X coordinate of the axis
            var x1 = graphXStart + ((t + 0.5) * (graphWidth - margin)) / (max + 1);
            // starting Y coord is the bottom of the graph
            var y1 = graphHeight;
            // draw the tick
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x1, y1 + (fontSize * 0.5));
            context.stroke();
            // get the label as a string
            var s = (t * dataScale).toFixed(dataScale < 1 ? 2 : 0);
            // check if the string is probably too wide to fit before drawing it
            if (canvas.width - x1 > (s.length * fontSize)) {
                context.fillText(s, x1 + (fontSize / 4), y1 + (fontSize * 1.0));
            }
        }

        if (cumulative) {
            // the Y axis label is only useful with the cumulative distribution
            context.textAlign = "right";
            // just increment from 0% to 90%
            var yAxisIncrement = 20;
            for (var t = 0; t < 100; t+= yAxisIncrement) {
                var x1 = graphXStart;
                var y1 = graphHeight - ((t + 0.5) * graphHeight) / (100);
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x1 - (fontSize * 0.5), y1);
                context.stroke();
                context.fillText(t + "%", x1 - (fontSize / 4), y1 - (fontSize * 0.25));
            }
        }

        if (trialData.average > max/2) {
            // data is closer to a normal distribution, put the text on the left
            var textX = graphWidth * 0.33;

        } else {
            // data is closer to a skewed negative binomial distribution, put the text on the right
            var textX = canvas.width - (graphWidth * 0.25);
        }

        context.fillStyle = style['t'];
        context.strokeStyle = style['to'];
        context.lineWidth = fontSize * 0.33;
        context.miterLimit = 2;

        // draw all the outlines first
    	histogramText(context, textX, fontSize * 2, trialData, titles, fontSize, dataScale, true);

        // draw the text on top
    	histogramText(context, textX, fontSize * 2, trialData, titles, fontSize, dataScale, false);

	}

	function histogramText(context, textX, textY, trialData, titles, fontSize, dataScale, outline) {
	    // just easier
        textY -= fontSize;

        // bold text for the title
        context.font = "bold " + fontSize + "px Arial";
        // center the title
        context.textAlign = "center";

        for (var i = 0; i < titles.length; i++) {
            // increment the Y coord
            textY += fontSize;
            // draw the title
            doText(context, titles[i], textX, textY, outline);
        }

        // increment the Y coord for a blank space
        textY += fontSize;

        // increment the Y coord
        textY += fontSize;
        // back to regular font
        context.font = fontSize + "px Arial";
        // Trials label on the right
        context.textAlign = "right";
        doText(context, "Trials:", textX - (fontSize * 0.5), textY, outline);
        // Trials data on the right
        context.textAlign = "left";
        doText(context, trialData.numTrials, textX + (fontSize * 0.5), textY, outline);

        // increment the Y coord
        textY += fontSize;
        // Average label on the right
        context.textAlign = "right";
        doText(context, "Average:", textX - (fontSize * 0.5), textY, outline);
        // Average value on the left
        context.textAlign = "left";
        doText(context, (trialData.average * dataScale).toFixed(2), textX + (fontSize * 0.5), textY, outline);

        // loop over the percentiles
        for (var i = 0; i < percentilesForHistogram.length; i++) {
            var percentile = percentilesForHistogram[i];
            // get the result object to calculate the percentile for us
            var percentileResult = trialData.percentileToResult(percentile) * dataScale;

            // increment the Y coord
            textY += fontSize;
            // label on the right
            context.textAlign = "right";
            doText(context, (percentile * 100).toFixed(0) + "th Percentile:", textX - (fontSize * 0.5), textY, outline);
            // value on the left
            context.textAlign = "left";
            doText(context, percentileResult.toFixed(2), textX + (fontSize * 0.5), textY, outline);
        }

        // increment the Y coord
        textY += fontSize;
        // label on the right
        context.textAlign = "right";
        doText(context, "Worst Case:", textX - (fontSize * 0.5), textY, outline);
        // value on the left
        context.textAlign = "left";
        doText(context, (trialData.max * dataScale).toFixed(dataScale < 1 ? 2 : 0), textX + (fontSize * 0.5), textY, outline);
	}

	function doText(context, text, x, y, outline) {
	    // we do the whole thing once with outlines, then again with the regular text
	    if (outline) {
            context.strokeText(text, x, y);

        } else {
            context.fillText(text, x, y);
        }
	}

    function convertToPng(canvas) {
        // quick and easy replace a canvas element with an equivalent image element for easy download

        // builds a huuuuge URL with the base-64 encoded PNG data embedded inside it
        var src = canvas.toDataURL();
        // todo: this doesn't work
        var fileName = canvas.saveName + ".png";
        // replace the canvas with an image
        canvas.parentElement.innerHTML = `
            <image download="${fileName}" src="${src}"></image>
        `;
    }

    function parseCanvasStyle(styleString) {
        // quick and dirty parser for the canvas CSS style hack
        var style = new Array();
        var regex = /([^";=]+)=([^";=]+)/g;
        var match;
        while (match = regex.exec(styleString)) {
            style[match[1]] = match[2];
        }
        // return an associative array
        return style;
    }

    function concatenateTitle(titles) {
        // quick and dirty concatenate the parts of the title with hyphens
        var html = "";
        for (var i = 0; i < titles.length; i++) {
            if (i > 0) {
                html += " - ";
            }
            html += titles[i];
        }
        return html;
    }

    function updateAllResults(scenarioRunner) {
        // update mission-level results, if there is more than one mission
		if (scenarioRunner.missionRunners.length > 1) {
            for (var i = 0; i < scenarioRunner.missionRunners.length; i++) {
                var missionRunner = scenarioRunner.missionRunners[i];

                // update the number of trials results
                updateResult(
                    getFirstChild(missionRunner.mission.resultElement, "trialResult"),
                    [missionRunner.mission.name, "Number of Runs"],
                    missionRunner.totalResults, false);

                // update the time results, or clear it if there is no time results
                updateResult(
                    getFirstChild(missionRunner.mission.resultElement, "timeResult"),
                    [missionRunner.mission.name, "Time"],
                    missionRunner.totalTimeResults, true);
            }
        }

        // update the total number of trials results
		updateResult(
		    getFirstChild(scenarioRunner.scenario.resultElement, "trialResult"),
		    [scenarioRunner.scenario.name, "Total Runs"],
		    scenarioRunner.totalResults, false);

        // update the total time results, or clear it if there is no time results
        updateResult(
            getFirstChild(scenarioRunner.scenario.resultElement, "timeResult"),
            [scenarioRunner.scenario.name, "Total Time"],
            scenarioRunner.totalTimeResults, true);
    }

    function clearResults() {
        // clear the overall trial and time result elements
        var scenarioResults = document.getElementById("scenarioResults");
	    getFirstChild(scenarioResults, "trialResult").innerHTML = "";
	    getFirstChild(scenarioResults, "timeResult").innerHTML = "";

        if (scenarioRunner != null) {
            for (var m = 0; m < scenarioRunner.missionRunners.length; m++) {
                // clear the trial and time result elements for each individual mission, if applicable
                var resultElement = scenarioRunner.missionRunners[m].mission.resultElement
                if (resultElement) {
                    getFirstChild(resultElement, "trialResult").innerHTML = "";
                    getFirstChild(resultElement, "timeResult").innerHTML = "";
                }
            }

    	    scenarioRunner = null;
        }
    }

    function stopAndclearResults() {
        stopRun();
        clearResults();
    }

    //==============================================================
    // Runner
    //==============================================================

    // global variable for simulation running
    var scenarioRunner;

    // run state
    var running = false;
    var stopped = true;

    // this is the number of runs after which we will stop
    // this is set on start, and can be incremented if start is used again after auto-stop occurs
    var stopNum = 0;

    // This is how long we will run the simulation before updating the UI
    var chunkMs = 100;

    function startRun() {
        // disable/enable everything accordingly
        document.getElementById('startButton').disabled = true;
        document.getElementById('samplesSelect').disabled = true;
        document.getElementById('stopAfter').disabled = true;
        setAllInputsDisabled(getScenario(), true);
        document.getElementById('stopButton').disabled = false;
        document.getElementById('clearButton').disabled = true;

        // update state
        stopped = false;

        // parse the UI into a model
        var model = getModel();

        // check if we already have a run in progress
        if (scenarioRunner != null) {
            // check if the model has changed by comparing toString()s.
            if (model.toString() == scenarioRunner.scenario.toString()) {
                // model hasn't changed, we can just resume where we left off
                // if we were auto-stopped then increment the number we will stop after
                if (stopNum > 0 && scenarioRunner.totalResults.numTrials >= stopNum) {
                    stopNum += readInt(document.getElementById('stopAfter').value);
                }

            } else {
                // otherwise, start over
                scenarioRunner = null;
            }
        }

        if (scenarioRunner == null) {
            // we're starting over, clear out all previous result UIs
            clearResults();
            // build a new runner
            scenarioRunner = new ScenarioRunner(model);

            // check for errors
            var errors = scenarioRunner.verify();
            if (errors.length > 0) {
                // oops!  there are errors.  Show them
                showErrors(errors);
                // clear the runner
                scenarioRunner = null;
                // sanity stop
                stopRun();
            } else {
                // everything's fine, clear out any previous errors
                clearErrors();
            }

            // initialize the auto stop number
            stopNum = readInt(document.getElementById('stopAfter').value);
        }

        // start the simulation
        runChunk();
    }

    function stopRun() {
        // disable/enable everything accordingly
        document.getElementById('startButton').disabled = false;
        document.getElementById('samplesSelect').disabled = false;
        document.getElementById('stopAfter').disabled = false;
        setAllInputsDisabled(getScenario(), false);
        document.getElementById('stopButton').disabled = true;
        document.getElementById('clearButton').disabled = false;
        // update state
        stopped = true;
        // the running simulation will check the stopped flag eventually and stop itself
    }

    function setAllInputsDisabled(node, disabled) {
        // quick and dirty way to disable/enable all inputs under the scenario config

        // basically we're looking for everything that has a disabled property and it's not set the way we want
        if (node.disabled == !disabled) {
            node.disabled = disabled;

        } else {
            // recursively search the child elements
            var children = node.children;
            for(var i = 0; i < children.length; i++) {
                setAllInputsDisabled(children[i], disabled);
            }
        }
    }

    function runChunk() {
        // preemptive check.  Since everything happens on the same event thread, the stop button event usually gets
        // handled in between runChunk()s.
        if (stopped) {
            // update state
            running = false;
            return;
        }

        // set state
        running = true;

        // we'll run trials until 100ms from now
        var endTime = Date.now() + chunkMs;

        // run the specified number of trials
		for (var trialCount = 1;; trialCount++) {
			scenarioRunner.run();

            // check the stop num
            if (stopNum > 0 && scenarioRunner.totalResults.numTrials >= stopNum) {
                break;
            }

			// check the time every 100 trials
			if (trialCount % 100 == 0 && Date.now() >= endTime) {
		        break;
			}
		}

        // update all the result UIs
        updateAllResults(scenarioRunner);

        // check if we've hit the stop after number
        if (stopNum > 0 && scenarioRunner.totalResults.numTrials >= stopNum) {
            // do this after updating the results UI
            stopRun();
        }

        // check stopped flag
        if (!stopped) {
            // cheap and easy way to emulate a background thread.  throw another chunk of runs on the UI event thread
            // and schedule it to run in 10ms.
            // todo: this may increase the call stack without bound?
            setTimeout(runChunk, 10);

        } else {
            // we're stopped, update state
            running = false;
        }
    }

    function about() {
        var container = document.getElementById("lotsOfWordsContainer")
        if (container.style.display === "none") {
            container.style.display = "block";

        } else {
            container.style.display = "none";
        }
    }


</script>
<body onload="initModel()">

<div class="titleBar">
    <div class="mainTitle">Warframe Drop Simulator</div>
    <div class="businessDiv">
        <div class="utilGroup">
            <div class="util examplesDiv">
                Examples:
                <span class="tooltip">
                    <select id="samplesSelect" onchange="setModelString(this.value)">
                        <option value="" disabled selected>Select one...</option>
                        <option value="" disabled>Frames...</option>
                        <!-- These frame samples are in rough order from least to most average time -->
                        <option value="Standard+Boss+Frame_{Assassinate_1_10_y_{Complete_1_3_0_{Helmet_38.7200_1}_{Chassis_38.7200_1}_{Systems_22.5600_1}}}">Standard Boss Frame</option>
                        <option value="Ash_{Grineer+Manic_1_0_y_{Kill_1_3_0_{Chassis_12.7776_1}_{Helmet_12.7776_1}_{Systems_7.4480_1}}}">Ash</option>
                        <option value="Gara_{Bounty+5-15_0_0_y_{Stage+2_1_0_6_{Chassis_7.5200_1}}_{Stage+3_1_0_3_{Chassis_30.5600_1}}}_{Bounty+10-20_0_0_y_{Stage+2_1_0_6_{Systems_9.5200_1}}_{Stage+3_1_0_3_{Systems_21.8200_1}}}_{Bounty+20-30_0_0_y_{Stage+3_1_0_9_{Helmet_8.4200_1}}_{Stage+4_1_0_3_{Helmet_20.5100_1}}}">Gara</option>
                        <option value="Octavia_{ODS_1_0_y_{Rotation+C_1_1_20_{Helmet_22.5600_1}}}_{Lua+Crossfire+With+Caches,+Music+Room_2_5_y_{Music+Room+(guessing+at+spawn+rate)_1_1_0_{Chassis_25.0000_1}}_{Cache+A_1_1_5_{Systems_22.5600_1}}}">Octavia</option>
                        <option value="Revenant_{Bounty+20-40_1_3_y_{Stage+2_1_1_3_{Systems_8.8700_1}}_{Stage+3_1_1_3_{Systems_8.6833_1}}_{Stage+4_1_1_3_{Systems_20.1700_1}}}_{Bounty+30-50_1_3_y_{Stage+2,3_2_1_3_{Chassis_8.4500_1}}_{Stage+4_1_1_3_{Chassis_8.2733_1}}_{Stage+5_1_1_3_{Chassis_19.3667_1}}}_{Bounty+40-60_1_9_y_{Stage+4_1_1_3_{Helmet_6.7600_1}}_{Stage+5_1_1_3_{Helmet_10.0200_1}}}">Revenant</option>
                        <option value="Revenant+(no+bail+early)_{Bounty+20-40_1_3_n_{Stage+2_1_1_3_{Systems_8.8700_1}}_{Stage+3_1_1_3_{Systems_8.6833_1}}_{Stage+4_1_1_3_{Systems_20.1700_1}}}_{Bounty+30-50_1_3_n_{Stage+2,3_2_1_3_{Chassis_8.4500_1}}_{Stage+4_1_1_3_{Chassis_8.2733_1}}_{Stage+5_1_1_3_{Chassis_19.3667_1}}}_{Bounty+40-60_1_9_n_{Stage+4_1_1_3_{Helmet_6.7600_1}}_{Stage+5_1_1_3_{Helmet_10.0200_1}}}">Revenant (no bail early)</option>
                        <option value="Equinox_{Uranus+Assassinate_1_10_y_{Kill+Tyl_1_8_0_{Night+Aspect_11.2800_1}_{Night+Chassis_12.9100_1}_{Night+Systems_12.9100_1}_{Night+Helmet_12.9100_1}_{Day+Aspect_11.2800_1}_{Day+Chassis_12.9100_1}_{Day+Systems_12.9100_1}_{Day+Helmet_12.9100_1}}}">Equinox</option>
                        <option value="Nidus_{Infested+Salvage_1_0_y_{Rotation+C_1_3_20_{Systems_14.2900_1}_{Helmet_14.2900_1}_{Chassis_14.2900_1}}}">Nidus</option>
                        <option value="Ivara_{Tier+1+Spy_1_10_y_{Rotation+C_1_1_0_{Systems_9.0900_1}}}_{Tier+2+Spy_1_10_y_{Rotation+C_1_1_0_{Chassis_5.6400_1}}}_{Tier+3+Spy_1_10_y_{Rotation+C_1_2_0_{Helmet_7.5200_1}_{BP_7.5200_1}}}">Ivara</option>
                        <option value="Khora_{Onslaught_3_0_y_{Rotation+A_2_1_5_{Chassis_8.3300_1}}_{Rotation+B_1_1_5_{Helmet_7.6900_1}}_{Rotation+C_1_2_5_{Systems_5.6400_1}_{BP_5.6400_1}}}">Khora</option>
                        <!-- The simulation isn't really built for these, but they do work -->
                        <option value="" disabled>Mods...</option>
                        <option value="Argon+Scope_{Torment_1_0_y_{Defeat_1_1_0_{Argon+Scope_4.0400_1}}}">Argon Scope</option>
                        <option value="Four+Riders_{Grineer+Manic_1_0_y_{Kill_1_1_0_{Four+Riders_0.3350_1}}}">Four Riders</option>
                        <option value="Vengeful+Revenant_{Conculyst_1_0_y_{Kill_1_1_0_{Vengeful+Revenant_0.4170_1}}}">Vengeful Revenant</option>
                        <option value="Condition+Overload_{Drekar+Butcher_1_0_y_{Kill_1_1_0_{Condition+Overload_0.0201_1}}}">Condition Overload</option>
                        <option value="Guardian+Derision_{Prod+Crewman_1_0_y_{Kill_1_1_0_{Guardian+Derision_0.0150_1}}}">Guardian Derision</option>
                        <option value="Full+Hunter+Set_{Level+15-25+Ghoul+Bounty_3_0_y_{Stage+1_1_1_3_{Adrenaline_33.3300_1}}_{Stage+2,+3_2_2_3_{Adrenaline_11.7400_1}_{Munitions_9.3900_1}}_{Stage+4_1_2_3_{Munitions_11.9000_1}_{Track_11.9000_1}}}_{Level+40-50+Ghoul+Bounty_4_0_y_{Stage+1_1_1_3_{Recovery_33.3300_1}}_{Stage+2,+3_2_2_3_{Recovery_11.7400_1}_{Synergy_9.3900_1}}_{Stage+4_1_3_3_{Recovery_10.2900_1}_{Synergy_8.2300_1}_{Command_8.2300_1}}_{Stage+5_1_2_3_{Synergy_11.9000_1}_{Command_11.9000_1}}}">Full Hunter Set</option>
                        <option value="All+Corrupted+Mods_{Derelict+Exterminate_1_5_y_{Vault_1_0_0_{Spoiled+Strike_4.1700_1}_{Corrupt+Charge_4.1700_1}_{Hollow+Point_4.1700_1}_{Magnum+Force_4.1700_1}_{Tainted+Clip_4.1700_1}_{Critical+Delay_4.1700_1}_{Heavy+Caliber_4.1700_1}_{Tainted+Mag_4.1700_1}_{Vile+Precision_4.1700_1}_{Narrow+Minded_4.1700_1}_{Fleeting+Expertise_4.1700_1}_{Blind+Rage_4.1700_1}_{Overextended_4.1700_1}_{Tainted+Shell_4.1700_1}_{Vicious+Spread_4.1700_1}_{Burdened+Magazine_4.1700_1}_{Anemic+Agility_4.1700_1}_{Vile+Acceleration_4.1700_1}_{Frail+Momentum_4.1700_1}_{Critical+Deceleration_4.1700_1}_{Creeping+Bullseye_4.1700_1}_{Transient+Fortitude_4.1700_1}_{Depleted+Reload_4.1700_1}}}">All Corrupted Mods</option>
                        <!-- Just some miscellaneous rough grinds -->
                        <option value="" disabled>Misc...</option>
                        <option value="Radshare_{Fissure_1_0_y_{Crack+Relic_4_1_0_{Rare_10.0000_1}}}">Radshare</option>
                        <option value="Solo+Radiant_{Fissure_1_0_y_{Crack+Relic_1_1_0_{Rare_10.0000_1}}}">Solo Radiant</option>
                        <option value="Three+Axi+S3+Relics_{Mot_1_0_y_{Rotation+C_1_1_20_{Axi+S3_11.1100_3}}}">Three Axi S3 Relics</option>
                        <option value="90+Rivens_{Sortie_1_0_y_{Complete_1_1_0_{Riven_26.0800_90}}}">90 Rivens</option>
                        <option value="Specific+Rifle+Riven_{Sortie_1_0_y_{Complete_1_1_0_{One+of+62+possible+Rifle+Rivens_0.1095_1}}}">Specific Rifle Riven</option>
                        <option value="Godlike+Lanka+Riven_{Roll_1_0_y_{Roll_1_1_0_{Crit+Chance,+Crit+Damage,+harmless+negative+stat_0.2131_1}}}">Godlike Lanka Riven</option>
                        <option value="Legendary+Core_{Sortie_1_0_y_{Complete_1_1_0_{Legendary+Core_0.1800_1}}}">Legendary Core</option>
                        <option value="Miter_{Ceres+Ass_1_0_y_{Kill+Krill_1_5_0_{Barrel_16.6700_1}_{Blade_16.6700_1}_{Handle_16.6700_1}_{Chassis_16.6700_1}_{Blueprint_16.6700_1}}}">Miter</option>
                        <!-- get ready to cry -->
                        <option value="Arcane+Energize+Set_{Tridolon+Hunt_1_0_y_{Hydrolyst+Capture_1_1_0_{Arcane+Energize_5.0000_10}}}">Arcane Energize Set</option>
                        <option value="Shadow+Stalker_{I+AM+YOUR+RECKONING_1_0_y_{WHAT+HAVE+YOU...+DONE_1_6_0_{Scimitar+Engines+BP_1.0050_1}_{Broken+War+BP_2.7650_1}_{Dread+BP_37.9400_1}_{Despair+BP_2.7650_1}_{Hate+BP_2.7650_1}_{War+BP_2.7650_1}}}">Shadow Stalker</option>
                        <option value="War+Parts_{Conculyst_1_0_y_{Kill_1_2_0_{War+Hilt+BP_0.5000_2}_{War+Blade+BP_0.5000_1}}}">War Parts</option>
                        <option value="Braton+and+Lato+Vandal_{Elite+Onslaught_3_0_y_{Rotation+A_2_1_5_{Lato+Receiver_2.0100_1}}_{Rotation+B_1_3_5_{Braton+Barrel_4.4200_1}_{Braton+Receiver_4.4200_1}_{Lato+BP_2.0100_1}}_{Rotation+C_1_3_5_{Braton+Stock_2.2100_1}_{Braton+BP_2.0100_1}_{Lato+Barrel_2.2100_1}}}">Braton and Lato Vandal</option>
                        <option value="Xiphos_{Tier+1+Sabotage_1_10_y_{Rotation+C_1_1_0_{Fuselage_0.5000_1}}}_{Tier+2+Sabotage_1_10_y_{Rotation+C_1_1_0_{Engines_0.5000_1}}}_{Tier+3+Sabotage_1_10_y_{Rotation+C_1_1_0_{Avionics_0.5000_1}}}">Xiphos</option>
                        <!-- just playing around -->
                        <!--<option value="http://localhost:63342/phun/sandbox/src/html/dropsim.html?m=_{Mission_1_0_y_{Drop_1_34_0_{a_1.0000_1}_{b_3.0000_1}_{c_3.0000_1}_{d_3.0000_1}_{e_3.0000_1}_{f_3.0000_1}_{g_3.0000_1}_{h_3.0000_1}_{i_3.0000_1}_{j_3.0000_1}_{k_3.0000_1}_{l_3.0000_1}_{m_3.0000_1}_{n_3.0000_1}_{o_3.0000_1}_{p_3.0000_1}_{q_3.0000_1}_{r_3.0000_1}_{s_3.0000_1}_{t_3.0000_1}_{u_3.0000_1}_{v_3.0000_1}_{w_3.0000_1}_{x_3.0000_1}_{y_3.0000_1}_{z_3.0000_1}_{aa_3.0000_1}_{bb_3.0000_1}_{cc_3.0000_1}_{dd_3.0000_1}_{ee_3.0000_1}_{ff_3.0000_1}_{gg_3.0000_1}_{hh_3.0000_1}}}&s=1000000&start=start">High Kurtosis</option>-->
                    </select>
                    <span class="tooltiptextbottom">Pre-fill the mission configuration with one of these examples.</span>
                </span>
            </div>
        </div>
    </div>
</div>

<div id="errorBar">
    <div id="error">
        <div class="errorLine">Javascript not enabled.</div>
    </div>
</div>

<div class="businessDiv">
    <div class="utilGroup">
        <div class="util">
            <span class="tooltip">
                <input id="startButton" class="button start" type="submit" value="Start" onClick="startRun()"/>
                <span class="tooltiptextbottom">Start the simulation.</span>
            </span>
        </div>
        <div class="util">
            <span class="tooltip">
                <input id="stopButton" class="button stop" type="submit" value="Stop" onClick="stopRun()" disabled/>
                <span class="tooltiptextbottom">Stop the simulation as soon as possible.</span>
            </span>
        </div>
        <div class="util stopAfterDiv">
            <div class="tooltip">
                <span class="label">Stop after:</span>
                <input id="stopAfter" class="inputStopAfter" type="number" value="1000000"/>
                <span class="tooltiptextbottom">Automatically stop the simulation after the given number of runs.</span>
            </div>
        </div>
        <div class="util">
            <span class="tooltip">
                <input id="clearResultsButton" class="button clear" type="submit" value="Clear" onClick="stopAndclearResults()"/>
                <span class="tooltiptextbottom">Clear all results.</span>
            </span>
        </div>
        <div class="util">
            <div class="popup">
                <input id="copyUrlButton" class="button urlButton popup" type="submit" value="Generate Link"
                       onClick="copyModelUrl()"/>
                <div class="popuptext" id="popupBox">
                    <input id="urlHolder" type="text" size="60" onblur="hideUrlPopup()"/>
                </div>
            </div>
        </div>
        <div class="util autoStartDiv">
            <div class="tooltip">
                <input id="copyUrlAutoStart" class="button" type="checkbox"/>
                <span class="label">Link Auto Starts</span>
                <span class="tooltiptextbottom">The link should automatically start the simulation when loaded.</span>
            </div>
        </div>
    </div>

    <div id="scenarioResults">
        <div class="trialResult"></div>
        <div class="timeResult"></div>
    </div>
</div>

<div id="scenario">
    <div class="scenarioDiv">
        <div class="modelTitle">Scenario</div>
        <div class="util">
            <span class="tooltip">
                <input id="clearButton" class="button clear" type="submit" value="Clear" onClick="clearScenario()"/>
                <span class="tooltiptext">Clears all scenario configuration.</span>
            </span>
        </div>
        <table class="fieldTable">
            <tr>
                <td class="tooltip">
                    Name:
                    <span class="tooltiptextbottom">The overall name for this collection of missions</span>
                </td>
                <td>
                    <input class="inputName" type="text"/>
                </td>
            </tr>
        </table>
    </div>
    <table class="missionTable">
        <tr class="add">
            <td>
                <span class="tooltip">
                    <input class="button addButton" type="submit" value="Add Mission"
                           onclick="addMission(document.getElementById('scenario'), true)"/>
                    <span class="tooltiptext">Add a mission to the scenario</span>
                </span>
            </td>
        </tr>

    </table>
</div>

<div class="titleBar">
    <div class="utilGroup">
        <div class="util">
            <span class="tooltip">
                <input id="about" class="button about" type="submit" value="Help" onClick="about()"/>
                <span class="tooltiptext">Click here for lots of words</span>
            </span>
        </div>
    </div>
    <div id="lotsOfWordsContainer" style="display: none;">
        <div class="lotsOfWords">
            <h1>What is this?</h1>
            <p>
                This is an RNG simulator.
                It's designed to run a <strong>scenario</strong> with random rewards until it's successful,
                start over and repeat it over and over again, and provide a statistical analysis of how long it
                actually takes to achieve success.
            </p>
            <p>
                Most of the drop rates used in the examples from from the official
                <a href="https://n8k6e2y6.ssl.hwcdn.net/repos/hnfvc0o3jnfvc873njb03enrf56.html">Warframe PC Drops</a>
                page.
            </p>
            <h2>Getting started</h2>
            <p>
                Select one of the pre-built scenarios from the <strong class="examplesDiv">Examples</strong> drop down
                at the top of the page.
            </p>
            <p>
                Click the <strong class="start">Start</strong> button to start the simulation.
            </p>
            <p>
                You can stop the simulation at any time by clicking the <strong class="stop">Stop</strong> button.
            </p>
            <p>
                The simulation runs the chosen scenario over and over again, up to a million times by default. While
                the simulation is running it will display a bunch of statistics. The most important ones are:
            </p>
            <ul>
                <li><strong>Average</strong>: This is the average number of missions or the average time that the
                    scenario took to succeeed. This is also known as the <strong>expected value</strong>.
                </li>
                <li><strong>90th Percentile</strong> and <strong>99th Percentile</strong>: This is the number of runs
                    or the time necesary in order to have a 90% or 99% chance of success.
                </li>
            </ul>

            <h1>In Depth</h1>

            <h2>Building the scenario</h2>
            <p>
                A <strong>Scenario</strong> repesents the overall goal, like "Obtaining Gara" or "Getting 90 Rivens".
                A scenario is built up in three layers:
            </p>
            <ol>
                <li>A Scenario contains one or more <strong>Missions</strong>. A Mission represents something that can
                    be repeated as many times as necessary, like a Cetus Bounty or finding a specific enemy.
                </li>
                <li>A Mission contains one or more <strong>Drop Events</strong>. A Drop Event represents something that
                    triggers an RNG-based reward, like completing a survival rotation or killing a specific enemy.
                </li>
                <li>A Drop Event contains one or more <strong>Items</strong>. An Item represents an individual object
                    that the Drop Event can reward, like a blueprint or a mod.
                </li>
            </ol>

            <h3>Drop Event order</h3>
            <p>
                Each time a mission is run, each of its Drop Events is run in the order in which they are listed. A
                Drop Event can be repeated in the same mission by setting <strong>Events Per Mission</strong>. This is
                mostly for when the Drop Event is an A Rotation, which typically repeats twice per Mission.
            </p>
            <p>
                The order in which Drop Events are listed should be the order in which they actually occur during the
                mission. See <strong>Bail Early</strong> below.
            </p>

            <h3>Defining the drop rate(s)</h3>
            <p>
                A <strong>drop rate</strong> is defined for each individual Item. This represents the probability of
                that Item being rewarded by the Drop Event containing it. The drop rate is a percentage, greater than
                0% and less than 100%.
            </p>
            <p>
                The sum of the drop rates for all the Items under a single Drop Event cannot add up to more than 100%.
                They can, however, add up to less than 100%. When the drop rates under a Drop Event add up to less than
                100% then that means the Drop Event has a chance of not dropping anything we're interested it.
            </p>

            <h3>Defining Success</h3>
            <p>
                An individual <strong>Item</strong> defines a <strong>Number Required</strong>. This is the total
                amount of that Item that must drop before that Item is considered successful. It's 1 by default, but
                you can make it higher to simulate how long it would take to get that many muliples of an item.
            </p>
            <p>
                There are some more advanced success requirements you can set at the Drop Event and Mission levels. You
                probably won't have to mess with these.
            </p>
            <ul>
                <li>By default, if a <strong>Drop Event</strong>'s <strong>Items Required</strong> field is left at
                    zero, then we require that all of its Items under that Drop Event reach their required numbers.
                    You can make Required Items greater than zero, in which case only that many Items have to be
                    sucessful. Note that this is a count of unique Items, and does not count multiples of a single
                    Item. The value of Required Items cannot be larger than the number of unique Items in the Drop
                    Event.
                </li>
                <li>By default, if a <strong>Mission</strong>'s <strong>Drop Events Required</strong> field is left at
                    zero, then then we require all of the Drop Events under that Mission to reached their required
                    Items. Like Required Items, You can make Required Drop Events greater than zero, in which case
                    only that many Drop Events have to be successful. Note that this is a count of Drop Events, not
                    individual Items. The value of Required Drop Events cannot be larger than the number of Drop Events
                    in the Mission.
                </li>
            </ul>
            <h4>Item Naming</h4>
            <p>
                A Name is assigned to each Item, uniquely identifying it. A single Drop Event can't contain two Items
                with the same name. However the same Item name can appear in more than one Drop Event, and in more
                than one Mission. When this happens, an Item dropping in one Drop Event counts towards every Item in
                the Scenario with the same name.
            </p>
            <h3>Time</h3>
            <p>
                In addition to tracking the total number of missions it takes to get success, we can also assign a time
                duration to each mission and/or drop event. The time is given as a <strong>whole number of
                minutes</strong>.
            </p>
            <ul>
                <li><strong>Mission</strong> time is used when a mission has some set amount of time it takes. This is
                    the base amount of time a mission takes regardless of drop events/rotations.
                </li>
                <li><strong>Drop Event</strong> time is used when a drop event itself has some set amount of time it
                    takes to trigger, like a survival rotation. If a drop event repeats more than once then its time
                    will be multipled by how many times it occurred during that mission.
                </li>
            </ul>
            <p>
                To determine the total amount of time a mission takes the base misson time, if any, is added to the
                times for each drop event that occurred, if any.
            </p>
            <p>
                Some missions, like Survival and Onslaught, have a set amount of time they and their drop
                events/rotations will take. With other mission types you have come up with an estimate.
            </p>
            <p>
                In the examples at the top of this page, I'm using the following time estimates:
            </p>
            <ul>
                <li><strong>Exterminate</strong>: 5 minutes</li>
                <li><strong>Capture</strong>: 5 minutes</li>
                <li><strong>Assassinate</strong>: 10 minutes.
                </li>
                <li>Finding all three supply caches during <strong>Sabotage</strong> or <strong>Lua Crossfire</strong>:
                    10 minutes
                </li>
                <li><strong>Spy</strong> if you're bad at Spy: 10 minutes</li>
                <li>Cetus <strong>bounty stage</strong>: 3 minutes</li>
                <li><strong>Infested Salvage</strong>: 20 minutes</li>
            </ul>
            <h3>Bail Early</h3>
            <p>
                If there are multiple Drop Events in a Mission, then it's possible for the later Drop Events to succeed
                during the run before the earlier ones. If there's a point in the mission after which all the Drop
                Events have already been successful, then we can <strong>bail early</strong>, ending the mission there
                and saving time.
            </p>
            <p>
                This behavior is enabled by default in order to give us the shortest possible time. You can force a
                particular mission not to bail early by unchecking the Bail Early checkbox under the mission.
            </p>
            <h3>Saving the scenario</h3>
            <p>
                Use the <strong class="urlButton">Generate Link</strong> button to build a link to the current Scenario.
            </p>
            <p>
                This link can be copied and shared. Opening it will pre-fill the page exactly how it currently appears.
            </p>
            <p>
                If you check the <strong class="autoStartDiv">Auto Start</strong> checkbox then the link will
                automatically start the Scenario when opened.
            </p>

            <h2>Running</h2>
            <p>
                You can start the scenario at any time using the <strong class="start">Start</strong> button.
            </p>
            <p>
                Note that while the scenario is running you can't make any changes or load up another scenario.
            </p>
            <p>
                The simulation itself is all in JavaScript, and runs entirely inside your browser.  You can actually
                download this HTML file and run it offline, there are no external dependencies.
            </p>
            <h2>Stopping</h2>
            <p>
                You can stop the simulation at any time using the <strong class="stop">Stop</strong> button.
            </p>
            <P>
                Note that if you have built a scenario that takes a very long time to complete, such as setting a drop
                rate to 0.0001%, then this may not take effect for a while. The simulation only checks the status of the
                Stop button every 100 trials.
            </p>
            <p>
                <strong class="warn">If you create a very long running scenario then it can potentially lock your
                    browser tab up while waiting for 100 trials to finish. Just don't do that.</strong>
            </p>
            <p>
                If you manually stop the simulation, and you haven't made any changes to the scenario, then you can
                start it again and it will resume where it left off.
            </p>
            <h2>Auto-stopping</h2>
            <p>
                The <strong class="stopAfterDiv">Stop after</strong> field allows you to specify a number of trials.
            </p>
            <p>
                The simulation will automatically stop after hitting that number. By default this is one million trials,
                which seems to be a good estimate for when most of the example scenarios settle in on something close to
                their true statistics.
            </p>
            <p>
                If the simulation has been automatically stopped, and you haven't made any changes to the scenario,
                then you can start it again and it will run a second set of trials up to the <strong>Stop after</strong>
                number. In other words, if your simulation reaches a million trials and you start it again, then it
                run a million more, for a total of two million. Starting again will run up to three million, etc.
            </p>

            <h2>Results</h2>
            <p>
                While the simulation is running, and after it has completed, it will update the statistical results at
                the top of the screen. If your scenario includes multiple missions, then each Mission will also get its
                own results section with statistics from just that mission's runs.
            </p>
            <p>
                Each result section contains statistics for the total number of runs. For the overall Scenario this is
                a
                sum of all the missions that were run before success. For individual Mission results, this just counts
                the number of that mission that were run.
            </p>
            <p>
                If time data was provided in the scenario, then each results section will have a second set of
                statistics for the time each run took. Again, the Scenario time result contains the sum of the times
                for all the missions run, and the Mission time result only counts the time spent running that mission.
            </p>
            <p>
                Each result section is further divided into two parts, <strong>Statistics</strong> and a <strong>Distribution
                Chart</strong>.
            </p>
            <h3>Statistics</h3>
            <p>
                The table on the right shows a number of statistics for the run:
            </p>
            <ul>
                <li><strong>Trials</strong>: This shows the total number of trials that have been run.</li>
                <li><strong>Average</strong>: This is the <a href="https://en.wikipedia.org/wiki/Expected_value">expected
                    average</a> of the distribution.  This is the average number of trials or amount of time until success.
                </li>
                <li><strong>Standard Deviation</strong>: <a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard
                    Deviation</a>
                    basically describes how spread out the data is from the average.
                </li>
                <li><strong>Skew</strong>: <a href="https://en.wikipedia.org/wiki/Skewness">Skew</a> describes how
                    slanted the data is towards one side or the other. A perfectly symmetric distribution has a skew
                    of zero.
                </li>
                <li><strong>Excess Kurtosis</strong>: <a href="https://en.wikipedia.org/wiki/Kurtosis">Excess
                    kurtosis</a>
                    basically describes how many extreme ouliers there are compared to a normal distribution. A
                    perfectly normal distribution has an excess kurtosis of zero.
                </li>
                <li><strong>50th Percentile</strong>: This is also known as the
                    <a href="https://en.wikipedia.org/wiki/Median">median</a>. If the distribution has a non-zero skew
                    then the median will be different from the average.
                </li>
                <li><strong>90th Percentile</strong>: The expected number of runs or expected amount of time required in
                    order to have a 90% chance of success.
                </li>
                <li><strong>99th Percentile</strong>: The expected number of runs or expected amount of time required in
                    order to have a 99% chance of success.
                </li>
                <li><strong>Worst Case</strong>: This is the maximum result from the current simulation run. Below
                    this statistic is shown the actual worst case result, including how many of each mission were run and
                    how many of each Item ultimately dropped.
                </li>
            </ul>
            <p>
                <strong class="warn">The Worst Case should be taken with a grain of salt; it just shows the worst case
                    from the current simulation run. Running the simulation over again with the same scenario can
                    produce a wildly different worst case.</strong>
            </p>

            <h3>Distribution Chart</h3>
            <p>
                The chart on the left shows a graphical view of the results. There are two possible views:
            </p>
            <ul>
                <li>
                    <p>
                        <strong>Probability Density</strong>:
                        This shows the <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability
                        distribution</a>.
                        The X axis represents possible results, and the height of the chart shows the relative frequency
                        of
                        that result.
                    </p>
                    <p>
                        Most of the results tend to cluster on the left side of this chart, below the average,
                        with a long tail of unlikely results extending very far to the right. The right edge of the
                        chart cuts off at the 99.9th Percentile, but the <strong>Worst Case</strong> value shows you
                        just how far it could extend if it was drawn out in full.
                    </p>
                </li>
                <li>
                    <p>
                        <strong>Cumulative Probability</strong>:
                        This shows the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative
                        probability distribution</a>. The X axis represents possible results, and the height of the
                        chart
                        shows the probability of getting that result or better, from 0% to 100%.
                    </p>
                    <p>
                        In this chart the value increases and approaches 100% as it goes to the right. Like the other
                        chart, this cuts off at the 99.9th Percentile to save space.
                    </p>
                </li>
            </ul>
            <p>
                You can switch between them using the buttons right above the chart.
            </p>
            <p>
                In both cases, there is a highlighted vertical line which shows where the average falls on the chart.
            </p>
            <p>
                The distribution of results basically follows a
                <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Negative Binomial
                    Distribution</a>, with Drop Events representing separate
                <a href="https://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli Trials</a>. If the scenario only
                contains one Drop Event with one Item, then it's exactly equal to a Negative Binomial Distribution, and
                you can actually calculate exact values for Average, 90th percentile, etc. However, with more than one
                Item or Drop Event things get complicated to the point where it's easier to run a simlation than it is
                to try and calculate the exact statistics.
            </p>

            <h4>Saving a chart</h4>
            <p>
                Most browsers should allow you to right-click on a chart and save it directly. However, if you simply
                click on a chart then it will be converted in-place to a PNG image, which you should definitely be
                able to save.
            </p>
            <h1>Notes on the Examples</h1>

            <h2>Frames</h2>
            <p>
                The frame scenarios are listed roughly in order of how long each one takes.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Standard+Boss+Frame_{Assassinate_1_10_y_{Complete_1_3_0_{Helmet_38.7200_1}_{Chassis_38.7200_1}_{Systems_22.5600_1}}}&start=start">Standard
                            Boss Frame</a>:
                    </td>
                    <td>
                        There's a lot of variance in how long the various assassination missions take, so I just guessed
                        an average of 10 minutes.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Ash_{Grineer+Manic_1_0_y_{Kill_1_3_0_{Chassis_12.7776_1}_{Helmet_12.7776_1}_{Systems_7.4480_1}}}&start=start">Ash</a>:
                    </td>
                    <td>
                        The "Mission" in this case is just killing a Manic.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Gara_{Bounty+5-15_0_0_y_{Stage+2_1_0_6_{Chassis_7.5200_1}}_{Stage+3_1_0_3_{Chassis_30.5600_1}}}_{Bounty+10-20_0_0_y_{Stage+2_1_0_6_{Systems_9.5200_1}}_{Stage+3_1_0_3_{Systems_21.8200_1}}}_{Bounty+20-30_0_0_y_{Stage+3_1_0_9_{Helmet_8.4200_1}}_{Stage+4_1_0_3_{Helmet_20.5100_1}}}&start=start">Gara</a>:
                    </td>
                    <td>
                        This is an example where the same Item can drop from multiple Drop Events, since each Gara part
                        drops from multiple bounty stages with a different drop rate in each stage.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Octavia_{ODS_1_0_y_{Rotation+C_1_1_20_{Helmet_22.5600_1}}}_{Lua+Crossfire+With+Caches,+Music+Room_2_5_y_{Music+Room+(guessing+at+spawn+rate)_1_1_0_{Chassis_25.0000_1}}_{Cache+A_1_1_5_{Systems_22.5600_1}}}&start=start">Octavia</a>:
                    </td>
                    <td>
                        ODS is pretty straightforward. For the other two parts I combined the Lua cache hunt with the
                        Music Room hunt, as you'll probably find the latter by accident while looking for caches. I took
                        a wild guess that the Music Room spawn rate is about 25%.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Revenant_{Bounty+20-40_1_3_y_{Stage+2_1_1_3_{Systems_8.8700_1}}_{Stage+3_1_1_3_{Systems_8.6833_1}}_{Stage+4_1_1_3_{Systems_20.1700_1}}}_{Bounty+30-50_1_3_y_{Stage+2,3_2_1_3_{Chassis_8.4500_1}}_{Stage+4_1_1_3_{Chassis_8.2733_1}}_{Stage+5_1_1_3_{Chassis_19.3667_1}}}_{Bounty+40-60_1_9_y_{Stage+4_1_1_3_{Helmet_6.7600_1}}_{Stage+5_1_1_3_{Helmet_10.0200_1}}}&start=start">Revenant</a>:
                    </td>
                    <td>
                        Like Gara, Revanant's parts drop from multiple bounty stages with different drop rates in each
                        one. Revanant takes a little longer tha Gara on average mostly because of the rare status on the
                        third part.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Revenant+(no+bail+early)_{Bounty+20-40_1_3_n_{Stage+2_1_1_3_{Systems_8.8700_1}}_{Stage+3_1_1_3_{Systems_8.6833_1}}_{Stage+4_1_1_3_{Systems_20.1700_1}}}_{Bounty+30-50_1_3_n_{Stage+2,3_2_1_3_{Chassis_8.4500_1}}_{Stage+4_1_1_3_{Chassis_8.2733_1}}_{Stage+5_1_1_3_{Chassis_19.3667_1}}}_{Bounty+40-60_1_9_n_{Stage+4_1_1_3_{Helmet_6.7600_1}}_{Stage+5_1_1_3_{Helmet_10.0200_1}}}&start=start">Revenant
                            (no bail early)</a>:
                    </td>
                    <td>
                        The Gara and Revanant scenarios above both enable Bail Early to cut down on time a little bit.
                        This is an example of what happens when you disable Bail Early on these kinds of multi-rotation
                        missions. In this case, bailing early seems to save about 10-15 minutes on the average, from
                        2.8 hours down to 2.6. Also, not bailing early makes the probability density chart for the total
                        time pretty cool.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Equinox_{Uranus+Assassinate_1_10_y_{Kill+Tyl_1_8_0_{Night+Aspect_11.2800_1}_{Night+Chassis_12.9100_1}_{Night+Systems_12.9100_1}_{Night+Helmet_12.9100_1}_{Day+Aspect_11.2800_1}_{Day+Chassis_12.9100_1}_{Day+Systems_12.9100_1}_{Day+Helmet_12.9100_1}}}&start=start">Equinox</a>:
                    </td>
                    <td>
                        Everyone's favorite example of a heavy grind is at most the fourth worst.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Nidus_{Infested+Salvage_1_0_y_{Rotation+C_1_3_20_{Systems_14.2900_1}_{Helmet_14.2900_1}_{Chassis_14.2900_1}}}&start=start">Nidus</a>:
                    </td>
                    <td>
                        It varies how long it actually takes to hit rotation C on infested Salvage, depending on
                        how on top of it your team is. I gave it a nice round 20 minutes.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Ivara_{Tier+1+Spy_1_10_y_{Rotation+C_1_1_0_{Systems_9.0900_1}}}_{Tier+2+Spy_1_10_y_{Rotation+C_1_1_0_{Chassis_5.6400_1}}}_{Tier+3+Spy_1_10_y_{Rotation+C_1_2_0_{Helmet_7.5200_1}_{BP_7.5200_1}}}&start=start">Ivara</a>:
                    </td>
                    <td>
                        I'm estimating 10 minutes for a Spy mission but if you're good at Spy, or have a friend who's
                        good at Spy, then they can be cut down to five minutes. However, even with the ten minute
                        estimate Ivara is still second place.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Khora_{Onslaught_3_0_y_{Rotation+A_2_1_5_{Chassis_8.3300_1}}_{Rotation+B_1_1_5_{Helmet_7.6900_1}}_{Rotation+C_1_2_5_{Systems_5.6400_1}_{BP_5.6400_1}}}&start=start">Khora</a>:
                    </td>
                    <td>
                        20 minutes to get to Rotation C is somewhat of an underestimate, but good enough. Disabling
                        early bailing adds about 20 minutes to the average, bringing it close to an even ten hours.
                    </td>
                </tr>
            </table>
            <h2>Mods</h2>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Argon+Scope_{Torment_1_0_y_{Defeat_1_1_0_{Argon+Scope_4.0400_1}}}&start=start">Argon
                            Scope</a>:
                    </td>
                    <td>
                        This one wouldn't be that bad if it wasn't time limited and only once a year or so.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Four+Riders_{Grineer+Manic_1_0_y_{Kill_1_1_0_{Four+Riders_0.3350_1}}}&start=start">Four
                            Riders</a>:
                    </td>
                    <td>
                        You have to kill a heck of a lot of Manics on average to get this stance mod.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Vengeful+Revenant_{Conculyst_1_0_y_{Kill_1_1_0_{Vengeful+Revenant_0.4170_1}}}&start=start">Vengeful
                            Revenant</a>:
                    </td>
                    <td>
                        This shows why loot frames like Ivara and Nekros are almost mandatory when farming Conculysts.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Condition+Overload_{Drekar+Butcher_1_0_y_{Kill_1_1_0_{Condition+Overload_0.0201_1}}}&start=start">Condition
                            Overload</a>:
                    </td>
                    <td>
                        The simulation lags a bit when you start getting into the really rare drops like this.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Guardian+Derision_{Prod+Crewman_1_0_y_{Kill_1_1_0_{Guardian+Derision_0.0150_1}}}&start=start">Guardian
                            Derision</a>:
                    </td>
                    <td>
                        I <i>still</i> don't have this one.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Full+Hunter+Set_{Level+15-25+Ghoul+Bounty_3_0_y_{Stage+1_1_1_3_{Adrenaline_33.3300_1}}_{Stage+2,+3_2_2_3_{Adrenaline_11.7400_1}_{Munitions_9.3900_1}}_{Stage+4_1_2_3_{Munitions_11.9000_1}_{Track_11.9000_1}}}_{Level+40-50+Ghoul+Bounty_4_0_y_{Stage+1_1_1_3_{Recovery_33.3300_1}}_{Stage+2,+3_2_2_3_{Recovery_11.7400_1}_{Synergy_9.3900_1}}_{Stage+4_1_3_3_{Recovery_10.2900_1}_{Synergy_8.2300_1}_{Command_8.2300_1}}_{Stage+5_1_2_3_{Synergy_11.9000_1}_{Command_11.9000_1}}}&start=start">Full
                            Hunter Set</a>:
                    </td>
                    <td>
                        Surprisingly easy to get a full set of these, even with the semi-limited nature of Ghoul events.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Corrupted+Mods_{Derelict+Exterminate_1_5_y_{Vault_1_0_0_{Spoiled+Strike_4.1700_1}_{Corrupt+Charge_4.1700_1}_{Hollow+Point_4.1700_1}_{Magnum+Force_4.1700_1}_{Tainted+Clip_4.1700_1}_{Critical+Delay_4.1700_1}_{Heavy+Caliber_4.1700_1}_{Tainted+Mag_4.1700_1}_{Vile+Precision_4.1700_1}_{Narrow+Minded_4.1700_1}_{Fleeting+Expertise_4.1700_1}_{Blind+Rage_4.1700_1}_{Overextended_4.1700_1}_{Tainted+Shell_4.1700_1}_{Vicious+Spread_4.1700_1}_{Burdened+Magazine_4.1700_1}_{Anemic+Agility_4.1700_1}_{Vile+Acceleration_4.1700_1}_{Frail+Momentum_4.1700_1}_{Critical+Deceleration_4.1700_1}_{Creeping+Bullseye_4.1700_1}_{Transient+Fortitude_4.1700_1}_{Depleted+Reload_4.1700_1}}}&start=start">All
                            Corrupted Mods</a>:
                    </td>
                    <td>
                        This is why trying to obtain all the corrupted mods without trading is crazy.
                    </td>
                </tr>
            </table>
            <h2>Misc</h2>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Radshare_{Fissure_1_0_y_{Crack+Relic_4_1_0_{Rare_10.0000_1}}}&start=start">Radshare</a>:
                    </td>
                    <td>
                        Radiant shares aren't bad on average.  However, I've personally seen it take 20 radshares to get
                        the rare, which put that particular run in the 99.98th percentile.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Solo+Radiant_{Fissure_1_0_y_{Crack+Relic_1_1_0_{Rare_10.0000_1}}}&start=start">Solo
                            Radiant</a>:
                    </td>
                    <td>
                        And this is why you find Radiant shares.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Three+Axi+S3+Relics_{Mot_1_0_y_{Rotation+C_1_1_20_{Axi+S3_11.1100_3}}}&start=start">Three
                            Axi S3 Relics</a>:
                    </td>
                    <td>
                        The vaulted relics drop only in the Void, so your options for efficient farming are limited.
                        This is how long it takes to get enough for the average number of necessary Radiant shares.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=90+Rivens_{Sortie_1_0_y_{Complete_1_1_0_{Riven_26.0800_90}}}&start=start">90
                            Rivens</a>:
                    </td>
                    <td>
                        How many Sorties does it take to fill your Riven collection to capacity? This one's interesting,
                        as it's very close to a normal distribution
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Specific+Rifle+Riven_{Sortie_1_0_y_{Complete_1_1_0_{One+of+62+possible+Rifle+Rivens_0.1095_1}}}&start=start">Specific
                            Rifle Riven</a>:
                    </td>
                    <td>
                        How many Sorties does it take to get a Riven for your favorite non-shotgun primary, out of 62
                        possibilities as of September 2018?
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Godlike+Lanka+Riven_{Roll_1_0_y_{Roll_1_1_0_{Crit+Chance,+Crit+Damage,+harmless+negative+stat_0.6394_1}}}&start=start">Godlike
                            Lanka Riven</a>:
                    </td>
                    <td>
                        Here, I'm definine "Godlike" as two of Crit Chance, Crit Damage, or Damage; the chances of which
                        are (3 choose 2) / (24 choose 2), and a harmless negative (10 out of 17).
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Legendary+Core_{Sortie_1_0_y_{Complete_1_1_0_{Legendary+Core_0.1800_1}}}&start=start">Legendary
                            Core</a>:
                    </td>
                    <td>
                        It's legendary for a reason.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Miter_{Ceres+Ass_1_0_y_{Kill+Krill_1_5_0_{Barrel_16.6700_1}_{Blade_16.6700_1}_{Handle_16.6700_1}_{Chassis_16.6700_1}_{Blueprint_16.6700_1}}}&start=start">Miter</a>:
                    </td>
                    <td>
                        I bet you forgot about farming all five parts of this thing.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Arcane+Energize+Set_{Tridolon+Hunt_1_0_y_{Hydrolyst+Capture_1_1_0_{Arcane+Energize_5.0000_10}}}&start=start">Arcane
                            Energize Set</a>:
                    </td>
                    <td>
                        Now I know why people have hundreds of Tridolon kills to their name.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Shadow+Stalker_{I+AM+YOUR+RECKONING_1_0_y_{WHAT+HAVE+YOU...+DONE_1_6_0_{Scimitar+Engines+BP_1.0050_1}_{Broken+War+BP_2.7650_1}_{Dread+BP_37.9400_1}_{Despair+BP_2.7650_1}_{Hate+BP_2.7650_1}_{War+BP_2.7650_1}}}&start=start">Shadow
                            Stalker</a>:
                    </td>
                    <td>
                        This particular scenario ends up having this highest Excess Kurtosis of all the examples, which
                        explains the surprising number of players still missing some Stalker drops after playing for
                        years.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=War+Parts_{Conculyst_1_0_y_{Kill_1_2_0_{War+Hilt+BP_0.5000_2}_{War+Blade+BP_0.5000_1}}}&start=start">War
                            Parts</a>:
                    </td>
                    <td>
                        Again, bring a loot frame to farm Conculysts.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Braton+and+Lato+Vandal_{Elite+Onslaught_3_0_y_{Rotation+A_2_1_5_{Lato+Receiver_2.0100_1}}_{Rotation+B_1_3_5_{Braton+Barrel_4.4200_1}_{Braton+Receiver_4.4200_1}_{Lato+BP_2.0100_1}}_{Rotation+C_1_3_5_{Braton+Stock_2.2100_1}_{Braton+BP_2.0100_1}_{Lato+Barrel_2.2100_1}}}&start=start">Braton
                            and Lato Vandal</a>:
                    </td>
                    <td>
                        Get ready to cry.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Xiphos_{Tier+1+Sabotage_1_10_y_{Rotation+C_1_1_0_{Fuselage_0.5000_1}}}_{Tier+2+Sabotage_1_10_y_{Rotation+C_1_1_0_{Engines_0.5000_1}}}_{Tier+3+Sabotage_1_10_y_{Rotation+C_1_1_0_{Avionics_0.5000_1}}}&start=start">Xiphos</a>:
                    </td>
                    <td>
                        Possibly the most ludicrous grind in the game.
                    </td>
                </tr>
            </table>
            <h1>Known Issues</h1>
            <ul>
                <li>
                    The charts don't work in Microsoft Edge.  Don't use Edge.
                </li>
            </ul>
        </div>
    </div>

    <div class="footerContainer">
        <div>
            <table>
                <tr>
                    <td width="50%" align="right" valign="bottom">
                        Buff00n
                    </td>
                    <td valign="bottom" width="24px"><img src="https://i.imgur.com/b5pNXKU.png" srcset="https://i.imgur.com/z6U8Oxs.png 2x"/></td>
                    <td width="50%" align="left" valign="bottom">
                        <a href="https://github.com/buff0000n/dropsim">source</a>
                    </td>
                </tr>
            </table>
            Updated: 2018-09-09
        </div>
    </div>
</div>
</body>
</html>